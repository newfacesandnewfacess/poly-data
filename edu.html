<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<title>방수판(1500×1200, 노치 400×400) · r147 UMD · 아이템제작(툴팁 포함)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html,body{height:100%;margin:0;background:#0b1220;color:#e9eef6;
            font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #stage{position:fixed;inset:0}
  #ui{
    position:fixed;left:12px;top:12px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;
    background:rgba(10,16,28,.86);border:1px solid rgba(255,255,255,.12);border-radius:12px;
    padding:8px 10px;backdrop-filter:blur(8px);z-index:10
  }
  #ui button, #ui select{
    font-size:16px;padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,.3);
    background:rgba(40,40,60,.85);color:#fff;cursor:pointer
  }
  #ui button:hover{ background:rgba(80,80,120,.95) }
  .label{padding:2px 6px;border-radius:6px;background:rgba(0,0,0,.65);
         border:1px solid rgba(255,255,255,.18);color:#fff;font-size:12px;white-space:nowrap}
  .label-dim{padding:2px 6px;border-radius:6px;background:rgba(0,0,0,.65);
             border:1px solid rgba(255,0,0,.6);color:#ff4444;font-size:12px;white-space:nowrap}

  /* ===== 아이템 제작 모달 ===== */
  .modal.hidden { display: none }
  .modal {
    position: fixed; inset: 0; z-index: 9999;
    background: rgba(0,0,0,.45); backdrop-filter: blur(4px);
    display:flex; align-items:center; justify-content:center;
  }
  .modal .window{
    width:95vw; height:95vh; border-radius:16px;
    background:#0f1424; color:#e9eef6; border:1px solid rgba(255,255,255,.12);
    display:flex; flex-direction:column; overflow:hidden;
    box-shadow: 0 20px 60px rgba(0,0,0,.5);
  }
  .m-header{
    display:flex; align-items:center; justify-content:space-between; gap:8px;
    padding:10px 14px; border-bottom:1px solid rgba(255,255,255,.12);
    background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,0));
  }
  .m-title{ font-weight:600 }
  .m-close{
    background:transparent; color:#fff; border:1px solid rgba(255,255,255,.25);
    padding:6px 10px; border-radius:10px; cursor:pointer;
  }
  .m-close:hover{ background:rgba(255,255,255,.08) }

  /* 본문: 롤(시트지) 영역 */
  .m-body{ flex:1; display:flex; align-items:stretch; position:relative }
  .rollArea{ flex:1; display:flex; align-items:flex-end; justify-content:center; overflow:hidden; position:relative }
  .rollGrid{
    position:relative; width:100%; height:100%; overflow:hidden;
    display:flex; align-items:flex-end; justify-content:center;
    background:
      repeating-linear-gradient(0deg, rgba(255,255,255,.08) 0, rgba(255,255,255,.08) 1px, transparent 1px, transparent var(--grid, 100px)),
      repeating-linear-gradient(90deg, rgba(255,255,255,.08) 0, rgba(255,255,255,.08) 1px, transparent 1px, transparent var(--grid, 100px));
  }
  .rollSheet{
    position:absolute; bottom:0; left:50%; transform:translateX(-50%);
    width:600px; height:0px;
    background:rgba(255,255,255,0.9);
    outline:1px solid rgba(255,0,0,.7);
  }
  .dragHandle{
    position:absolute; bottom:0; left:50%; transform:translateX(-50%);
    width:280px; text-align:center; padding:8px 10px; margin-bottom:6px;
    background:rgba(0,0,0,.55); border:1px solid rgba(255,255,255,.25); border-radius:12px;
    cursor:ns-resize; user-select:none; font-size:13px;
  }
  .lengthIndicator{
    position:absolute; right:10px; bottom:10px;
    background:rgba(0,0,0,.65); border:1px solid rgba(255,255,255,.25);
    padding:8px 10px; border-radius:10px; font-weight:600; min-width:120px; text-align:right;
  }

  /* 절단 조각 레이어 & 조각들 */
  .cutLayer{
    position:absolute; bottom:0; left:50%; transform:translateX(-50%);
    width:600px; height:0; pointer-events:none;
  }
  .cutPiece{
    position:absolute; background:rgba(255,200,0,.9);
    box-shadow:inset 0 0 0 1px rgba(0,0,0,.35);
    border-radius:6px; transition:width .35s ease,height .35s ease, opacity .3s ease;
  }
  .cutPiece.shrink{ width:1px !important; height:1px !important; opacity:0; }
  .cutPiece .num{
    position:absolute; right:6px; bottom:6px; font-weight:700; font-size:12px;
    background:#111; color:#ffd54d; padding:2px 6px; border-radius:6px;
  }

  /* 모달 내부에서 바디로 스크롤 전파 방지 */
  #makerModal, #makerModal * { overscroll-behavior: contain; }

  /* 굵은 가로 가이드 라인(롤과 함께 위로 이동) */
  .guide-line{
    position:absolute;
    left:50%; transform:translateX(-50%);
    height:0;
    border-top:5px solid #f00;
    opacity:.95;
    pointer-events:none;
  }

  /* ====== 단계 상세 툴팁 ====== */
  .tip{ position:fixed; z-index:12; min-width:280px; max-width:360px;
        background:rgba(12,18,32,.96); border:1px solid rgba(255,255,255,.14);
        border-radius:14px; box-shadow:0 12px 40px rgba(0,0,0,.45);
        color:#e9eef6; overflow:hidden; pointer-events:auto; }
  .tip.hidden{ display:none }
  .tip-header{ display:flex; align-items:center; justify-content:space-between; gap:8px;
               padding:8px 10px; font-weight:600; border-bottom:1px solid rgba(255,255,255,.12) }
  .tip-body{ padding:10px }
  .tip-body img{ width:100%; height:auto; border-radius:10px; display:block; margin:0 0 8px 0;
                 background:linear-gradient(135deg,#1a2238,#0f1628) }
  .tip-close{ background:transparent; color:#fff; border:1px solid rgba(255,255,255,.25);
              padding:4px 8px; border-radius:8px; cursor:pointer; }
  .tip-close:hover{ background:rgba(255,255,255,.08) }
</style>
</head>
<body>
<div id="stage"></div>

<!-- UI -->
<div id="ui">
  <button id="toggleDims">치수: ON</button>
  <button id="toggleMarks">마킹영역: ON</button>
  <button id="toggleCoords">좌표: OFF</button>
  <button id="toggleMaker">재단 보기</button>

  <!-- 작업순서: 자동플레이(시작/중지) -->
  <button id="toggleSeq">자동플레이</button>

  <!-- 단일 단계 이동 -->
  <span style="display:inline-flex;gap:6px;align-items:center;margin-left:6px">
    <span>단계</span>
    <select id="seqStep" title="단일 단계 선택" style="min-width:68px"></select>
    <button id="btnGoStep" title="선택 단계로 이동/표시">단계 이동</button>
  </span>
</div>

<!-- 단계 상세 툴팁 -->
<div id="stepTip" class="tip hidden" role="dialog" aria-live="polite">
  <div class="tip-header">
    <div id="tipTitle">단계 상세</div>
    <button class="tip-close" id="tipClose">닫기</button>
  </div>
  <div class="tip-body">
    <img id="tipImg" alt="단계 이미지" />
    <div id="tipHtml">내용이 여기에 표시됩니다.</div>
  </div>
</div>

<!-- libs -->
<script src="./lib/three.min.js"></script>
<script src="./lib/controls/OrbitControls.js"></script>
<script src="./lib/renderers/CSS2DRenderer.js"></script>

<script>
/* =========================
 * 0) 공통 설정
 * ======================= */
const W = 1500, D = 1200;
const T = 0.1;
const NOTCH_X = 400, NOTCH_Z = 400, NOTCH_ORIGIN_Z = 800;
const Y_TOP = T;
const WALL_H = 300, WALL_T = 70;
const TRI_W = 40, TRI_H = 40;
const PILLAR_H = 300;
const fmt0 = n => Number(n).toFixed(0);

/* =========================
 * 1) three.js scene
 * ======================= */
const scene   = new THREE.Scene();
const camera  = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 10000);
const renderer= new THREE.WebGLRenderer({ antialias:true, alpha:false, powerPreference:'high-performance' });
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.5));
document.getElementById('stage').appendChild(renderer.domElement);

const labelRenderer = new THREE.CSS2DRenderer();
labelRenderer.setSize(innerWidth,innerHeight);
labelRenderer.domElement.style.position="fixed";
labelRenderer.domElement.style.inset="0";
labelRenderer.domElement.style.pointerEvents="none";
document.body.appendChild(labelRenderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.dampingFactor = 0.08;
controls.enablePan = true; controls.screenSpacePanning = true; controls.panSpeed = 1.2;
controls.zoomSpeed = 1.0; controls.rotateSpeed = 0.8;
controls.mouseButtons = { LEFT:THREE.MOUSE.PAN, MIDDLE:THREE.MOUSE.DOLLY, RIGHT:THREE.MOUSE.ROTATE };
controls.touches      = { ONE:THREE.TOUCH.PAN, TWO:THREE.TOUCH.DOLLY_ROTATE };

scene.add(new THREE.HemisphereLight(0xffffff,0x223344,0.85));
scene.add(new THREE.AxesHelper(200));
const grid = new THREE.GridHelper(4000, 40, 0x3355ff, 0x223355);
grid.material.opacity = 0.25; grid.material.transparent = true;
scene.add(grid);

camera.position.set(1600,800,1600);
controls.target.set(W/2,0,D/2);

/* 바닥+노치 */
const plateShape = new THREE.Shape();
plateShape.moveTo(0,0); plateShape.lineTo(W,0); plateShape.lineTo(W,D);
plateShape.lineTo(0,D); plateShape.lineTo(0,0);
const hole = new THREE.Path();
hole.moveTo(0,NOTCH_ORIGIN_Z);
hole.lineTo(NOTCH_X,NOTCH_ORIGIN_Z);
hole.lineTo(NOTCH_X,NOTCH_ORIGIN_Z+NOTCH_Z);
hole.lineTo(0,NOTCH_ORIGIN_Z+NOTCH_Z);
hole.lineTo(0,NOTCH_ORIGIN_Z);
plateShape.holes.push(hole);
const plateGeo  = new THREE.ExtrudeGeometry(plateShape,{ depth:T, bevelEnabled:false, steps:1 });
const plateMesh = new THREE.Mesh(plateGeo, new THREE.MeshPhongMaterial({ color:0xf0d8b0 }));
plateMesh.rotation.x = -Math.PI/2;
scene.add(plateMesh);

/* 주요 점/센트로이드 */
const V = {
  A:new THREE.Vector3(0,       Y_TOP,   0),
  B:new THREE.Vector3(W,       Y_TOP,   0),
  C:new THREE.Vector3(W,       Y_TOP,  -D),
  D:new THREE.Vector3(0,       Y_TOP,  -D),
  E:new THREE.Vector3(0,       Y_TOP,  -NOTCH_ORIGIN_Z),
  F:new THREE.Vector3(NOTCH_X, Y_TOP,  -NOTCH_ORIGIN_Z),
  G:new THREE.Vector3(NOTCH_X, Y_TOP,  -(NOTCH_ORIGIN_Z+NOTCH_Z))
};
function polygonCentroid(pts){
  let A=0,cx=0,cz=0;
  for(let i=0;i<pts.length;i++){
    const p=pts[i], q=pts[(i+1)%pts.length];
    const cross=p.x*q.z - q.x*p.z;
    A+=cross; cx+=(p.x+q.x)*cross; cz+=(p.z+q.z)*cross;
  }
  A*=0.5; return new THREE.Vector3(cx/(6*A), Y_TOP, cz/(6*A));
}
const CENTROID = polygonCentroid([V.A,V.B,V.C,V.D,V.E,V.F,V.G]);

/* 유틸 & 그룹 */
const matWall   = new THREE.MeshPhongMaterial({ color: 0xe5c99b });
const matTri    = new THREE.MeshPhongMaterial({ color: 0xcaa77a });
const matPillar = new THREE.MeshPhongMaterial({ color: 0xd7b98a });

function makeLabel(pos,text,cls='label'){
  const el=document.createElement('div'); el.className=cls; el.textContent=text;
  const lab=new THREE.CSS2DObject(el); lab.position.copy(pos); return lab;
}
const dimsGroup = new THREE.Group(); scene.add(dimsGroup);
const coordGroup = new THREE.Group(); scene.add(coordGroup);
const markGroup = new THREE.Group(); scene.add(markGroup);

/* 작업순서 전용 그룹 */
const seqAutoGroup   = new THREE.Group(); scene.add(seqAutoGroup);   // 자동플레이 때 표시
const seqSingleGroup = new THREE.Group(); scene.add(seqSingleGroup); // 단일 단계 표시(항상 1개)

/* 그룹 클리어 */
function clearGroup(g){
  for(let i=g.children.length-1;i>=0;i--){
    const c=g.children[i];
    if (c.isCSS2DObject && c.element) c.element.remove();
    g.remove(c);
  }
}

/* 치수/마킹 보조 함수 */
function addDimSegment(a,b,text){
  const g = new THREE.BufferGeometry().setFromPoints([a,b]);
  const m = new THREE.LineDashedMaterial({ color:0xffffff, dashSize:40, gapSize:20, transparent:true, opacity:.95 });
  const line = new THREE.Line(g,m); line.computeLineDistances(); dimsGroup.add(line);
  if(text){ const mid=a.clone().add(b).multiplyScalar(0.5); dimsGroup.add(makeLabel(mid,text,'label-dim')); }
}
function addTickAt(p,dir,len=20){
  const a=p.clone().add(dir.clone().multiplyScalar(-len*0.5));
  const b=p.clone().add(dir.clone().multiplyScalar( len*0.5));
  const g=new THREE.BufferGeometry().setFromPoints([a,b]);
  dimsGroup.add(new THREE.Line(g,new THREE.LineBasicMaterial({color:0xffffff,transparent:true,opacity:.95})));
}

/* 벽/면목/기둥 */
function addVerticalBoard(p1, p2, name1, name2, H = WALL_H, t = WALL_T, place = 'outset') {
  const dir = p2.clone().sub(p1); dir.y = 0;
  const L   = Math.max(0.0001, Math.hypot(dir.x, dir.z));
  const angY = Math.atan2(dir.z, dir.x);
  const wall = new THREE.Mesh(new THREE.BoxGeometry(L,H,t), matWall);
  const mid = p1.clone().add(p2).multiplyScalar(0.5);
  wall.position.set(mid.x, Y_TOP + H / 2, mid.z);
  wall.rotation.y = angY;
  if (place !== 'center') {
    const n = new THREE.Vector3(-dir.z, 0, dir.x).normalize();
    const toCent = CENTROID.clone().sub(mid).setY(0);
    const nIsIn = n.dot(toCent) > 0;
    const outwardN = nIsIn ? n.clone().multiplyScalar(-1) : n.clone();
    const inwardN  = outwardN.clone().multiplyScalar(-1);
    const offsetN  = (place === 'inset') ? inwardN : outwardN;
    wall.position.add(offsetN.multiplyScalar(t * 0.5));
  }
  scene.add(wall);

  const t1 = p1.clone(); t1.y = Y_TOP + H;
  const t2 = p2.clone(); t2.y = Y_TOP + H;
  coordGroup.add(makeLabel(t1.clone().add(new THREE.Vector3(0,20,0)), `${name1}@ (${fmt0(t1.x)},${fmt0(t1.y)},${fmt0(t1.z)})`));
  coordGroup.add(makeLabel(t2.clone().add(new THREE.Vector3(0,20,0)), `${name2}@ (${fmt0(t2.x)},${fmt0(t2.y)},${fmt0(t2.z)})`));
  return wall;
}
function createTriShape(w=TRI_W,h=TRI_H){
  const s=new THREE.Shape(); s.moveTo(0,0); s.lineTo(w,0); s.lineTo(0,h); s.lineTo(0,0); return s;
}
function addTriPrismOnEdge(p1,p2,label='edge',w=TRI_W,h=TRI_H){
  const zAxis = p2.clone().sub(p1); zAxis.y=0; const L=Math.max(0.0001,zAxis.length()); zAxis.normalize();
  const yAxis = new THREE.Vector3(0,1,0);
  let   xAxis = yAxis.clone().cross(zAxis).normalize();
  const mid   = p1.clone().add(p2).multiplyScalar(0.5);
  const toC   = CENTROID.clone().sub(mid).setY(0);
  if(xAxis.dot(toC)<0) xAxis.negate();
  const tri = createTriShape(w,h);
  const geo = new THREE.ExtrudeGeometry(tri,{ depth:L, bevelEnabled:false, steps:1 });
  const mesh= new THREE.Mesh(geo,matTri);
  mesh.setRotationFromMatrix(new THREE.Matrix4().makeBasis(xAxis,yAxis,zAxis));
  mesh.position.copy(p1);
  scene.add(mesh);
  return mesh;
}
function addAxisAlignedPillar(corners, h = PILLAR_H, label = '') {
  const xs = corners.map(p => p.x), zs = corners.map(p => p.z);
  const minX = Math.min(...xs), maxX = Math.max(...xs);
  const minZ = Math.min(...zs), maxZ = Math.max(...zs);
  const Wp = Math.abs(maxX - minX), Dp = Math.abs(maxZ - minZ);
  const cx = (minX + maxX) / 2, cz = (minZ + maxZ) / 2;

  const mesh = new THREE.Mesh(new THREE.BoxGeometry(Wp, h, Dp), matPillar);
  mesh.position.set(cx, Y_TOP + h / 2, cz);
  scene.add(mesh);
  const ty = Y_TOP + h;
  [[minX, minZ], [maxX, minZ], [maxX, maxZ], [minX, maxZ]].forEach((p, i) => {
    const v = new THREE.Vector3(p[0], ty, p[1]);
    coordGroup.add(makeLabel(v.clone().add(new THREE.Vector3(0,20,0)), `${label?label+' ':''}T${i+1} (${fmt0(v.x)},${fmt0(v.y)},${fmt0(v.z)})`));
  });
  return mesh;
}

/* 치수/마킹 */
function addDimToward(p1,p2,text,offset=-60){
  const d=p2.clone().sub(p1).setY(0).normalize();
  const n=new THREE.Vector3(-d.z,0,d.x);
  const mid=p1.clone().add(p2).multiplyScalar(0.5);
  const sgn = (n.dot(CENTROID.clone().sub(mid).setY(0))>=0)? 1 : -1;
  const off=n.multiplyScalar(sgn*offset);
  const a=p1.clone().add(off); a.y=Y_TOP+1;
  const b=p2.clone().add(off); b.y=Y_TOP+1;
  addDimSegment(a,b,text);
}
function addHeightDimAt(point,height=300,text='300',offset=100){
  const outward = point.clone().setY(0).sub(CENTROID.clone().setY(0));
  if(outward.lengthSq()===0) outward.set(1,0,0);
  outward.normalize().multiplyScalar(offset);
  const base=new THREE.Vector3(point.x+outward.x,Y_TOP,point.z+outward.z);
  const top =new THREE.Vector3(point.x+outward.x,Y_TOP+height,point.z+outward.z);
  addDimSegment(base,top,text);
  const tickDir=new THREE.Vector3(-outward.z,0,outward.x).normalize();
  addTickAt(base,tickDir); addTickAt(top,tickDir);
}

/* 바닥면 & 임의 사각(회전은 addMarkQuad3D가 처리) */
function addMarkRect(cx,cz,w,d,label='MARK'){
  const mesh = new THREE.Mesh(new THREE.PlaneGeometry(w,d),
    new THREE.MeshBasicMaterial({ color:0xff0000, transparent:true, opacity:0.22, depthWrite:false }));
  mesh.rotation.x = -Math.PI/2; mesh.position.set(cx, Y_TOP+0.05, cz); markGroup.add(mesh);
  const hw=w/2, hd=d/2;
  const poly=[[-hw,0,-hd],[hw,0,-hd],[hw,0,hd],[-hw,0,hd]].map(([x,_,z])=>new THREE.Vector3(cx+x, Y_TOP+0.06, cz+z));
  const g=new THREE.BufferGeometry().setFromPoints([...poly, poly[0]]);
  const line=new THREE.Line(g,new THREE.LineBasicMaterial({ color:0xff0000, transparent:true, opacity:0.9 }));
  markGroup.add(line);
  markGroup.add(makeLabel(new THREE.Vector3(cx, Y_TOP+0.06, cz), label, 'label-dim'));
}
function addMarkQuad3D(corners, label='MARK', { color=0xff0000, opacity=0.22, outline=true, target } = {}){
  const group = target || markGroup;
  const p = corners.map(c => new THREE.Vector3(c.x, (c.y ?? Y_TOP+0.05), c.z));
  const pos = new Float32Array([
    p[0].x,p[0].y,p[0].z,  p[1].x,p[1].y,p[1].z,  p[2].x,p[2].y,p[2].z,
    p[0].x,p[0].y,p[0].z,  p[2].x,p[2].y,p[2].z,  p[3].x,p[3].y,p[3].z,
  ]);
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  geo.computeVertexNormals();
  const mat = new THREE.MeshBasicMaterial({ color, transparent:true, opacity, side:THREE.DoubleSide, depthWrite:false });
  const mesh = new THREE.Mesh(geo, mat);
  group.add(mesh);
  if (outline) {
    const loopGeo = new THREE.BufferGeometry().setFromPoints([p[0],p[1],p[2],p[3],p[0]]);
    const loopMat = new THREE.LineBasicMaterial({ color, transparent:true, opacity:0.9 });
    group.add(new THREE.Line(loopGeo, loopMat));
  }
  const centroid = p[0].clone().add(p[1]).add(p[2]).add(p[3]).multiplyScalar(0.25);
  const normal = new THREE.Triangle(p[0],p[1],p[2]).getNormal(new THREE.Vector3()).normalize();
  const labelPos = centroid.clone().add(normal.multiplyScalar(5));
  group.add(makeLabel(labelPos, label, 'label-dim'));
  return mesh;
}
function addMarkRectVerticalX(x, y1, y2, z1, z2, label='MARK', opts){
  return addMarkQuad3D([
    {x:x, y:y1, z:z1},
    {x:x, y:y1, z:z2},
    {x:x, y:y2, z:z2},
    {x:x, y:y2, z:z1},
  ], label, opts);
}
function addMarkRectVerticalZ(z, y1, y2, x1, x2, label='MARK', opts){
  return addMarkQuad3D([
    {x:x1, y:y1, z:z},
    {x:x2, y:y1, z:z},
    {x:x2, y:y2, z:z},
    {x:x1, y:y2, z:z},
  ], label, opts);
}

/* 두께 치수(예시) */
function addThicknessDimOnEdgeOutside(p1, p2, thickness=70, text='70', y=Y_TOP+40, gap=35){
  const mid = p1.clone().add(p2).multiplyScalar(0.5);
  const dir = p2.clone().sub(p1); dir.y = 0; dir.normalize();
  let n   = new THREE.Vector3(-dir.z, 0, dir.x);
  const toOut = mid.clone().sub(CENTROID.clone().setY(mid.y));
  if (n.dot(toOut) < 0) n.negate();
  const innerFace = mid.clone().add(n.clone().multiplyScalar(-thickness/2)); innerFace.y = y;
  const outerFace = mid.clone().add(n.clone().multiplyScalar( thickness/2)); outerFace.y = y;
  const a = innerFace.clone().add(n.clone().multiplyScalar(gap));
  const b = outerFace.clone().add(n.clone().multiplyScalar(gap));
  const extMat = new THREE.LineBasicMaterial({ color:0xffffff, transparent:true, opacity:.85 });
  dimsGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([outerFace, b]), extMat));
  addDimSegment(a, b, text);
  addTickAt(a, dir); addTickAt(b, dir);
}

/* 장면 생성 */
addVerticalBoard(V.A,V.E,'A','E',WALL_H,WALL_T,'outset');
addVerticalBoard(V.E,V.F,'E','F',WALL_H,WALL_T,'outset');
addVerticalBoard(V.F,V.G,'F','G',WALL_H,WALL_T,'outset');
addVerticalBoard(V.G,V.C,'G','C',WALL_H,WALL_T,'outset');

addTriPrismOnEdge(V.E,V.A,'AE');
addTriPrismOnEdge(V.F,V.E,'EF');
addTriPrismOnEdge(V.G,V.F,'FG');
addTriPrismOnEdge(V.C,V.G,'GC');

(function addCornerWedgeF(){
  const mat = matTri;
  const VTX = [
    new THREE.Vector3(400, Y_TOP+0,  -800),
    new THREE.Vector3(400, Y_TOP+40, -800),
    new THREE.Vector3(400, Y_TOP+0,  -760),
    new THREE.Vector3(440, Y_TOP+0,  -800),
    new THREE.Vector3(440, Y_TOP+0,  -760)
  ];
  const idx = [ 0,3,4, 0,4,2,  1,3,0, 1,0,2,  1,2,4, 1,4,3 ];
  const pos = new Float32Array(VTX.flatMap(v=>[v.x,v.y,v.z]));
  const geo = new THREE.BufferGeometry(); geo.setAttribute('position', new THREE.BufferAttribute(pos,3)); geo.setIndex(idx); geo.computeVertexNormals();
  scene.add(new THREE.Mesh(geo,mat));
})();

addAxisAlignedPillar([{x:0,y:0,z:-800},{x:-70,y:0,z:-800},{x:-70,y:0,z:-870},{x:0,y:0,z:-870}], 300, '');
addAxisAlignedPillar([{x:400,y:0,z:-1200},{x:330,y:0,z:-1200},{x:330,y:0,z:-1270},{x:400,y:0,z:-1270}], 300, '');

addDimToward(V.A,V.B,'1500');
addDimToward(V.B,V.C,'1200');
addDimToward(V.E,V.F,'400');
addDimToward(V.F,V.G,'400');
addHeightDimAt(V.A, 300, '300');
addThicknessDimOnEdgeOutside(V.A, V.E, 70, '70', Y_TOP+340,35);

/* ===== 샘플 마킹(유지) ===== */
addMarkRectVerticalX(0, Y_TOP, Y_TOP+300, 0, -50, '마킹영역-50mm');
addMarkRect(750, -25, 1500, 50, '마킹영역-50mm');
addMarkQuad3D([{x:0,y:Y_TOP+40,z:0},{x:0,y:Y_TOP+40,z:-50},{x:40,y:0,z:-50},{x:40,y:0,z:0}], '마킹영역-50mm');
addMarkRect(1450, -600, 100, 1200, '마킹영역-100mm');
addMarkQuad3D([{x:1500,y:Y_TOP+40,z:-1200},{x:1500,y:0,z:-1160},{x:1400,y:0,z:-1160},{x:1400,y:Y_TOP+40,z:-1200}], '마킹영역-100mm');
addMarkRectVerticalZ(-1200, Y_TOP,Y_TOP+300,  1400,  1500, '마킹영역-100mm');
addMarkQuad3D([{x:1500,y:Y_TOP+300,z:-1200},{x:350,y:Y_TOP+300,z:-1200},{x:350,y:Y_TOP+300,z:-1250},{x:1500,y:Y_TOP+300,z:-1250}], '마킹영역-50mm');
addMarkQuad3D([{x:350,y:Y_TOP+300,z:-1200},{x:400,y:Y_TOP+300,z:-1200},{x:400,y:Y_TOP+300,z:-800},{x:350,y:Y_TOP+300,z:-800}], '마킹영역-50mm');
addMarkQuad3D([{x:350,y:Y_TOP+300,z:-800},{x:350,y:Y_TOP+300,z:-850},{x:-50,y:Y_TOP+300,z:-850},{x:-50,y:Y_TOP+300,z:-800}], '마킹영역-50mm');
addMarkQuad3D([{x:-50,y:Y_TOP+300,z:-800},{x:-50,y:Y_TOP+300,z:0},{x:0,y:Y_TOP+300,z:0},{x:0,y:Y_TOP+300,z:-800}], '마킹영역-50mm');
addMarkRect(500, -500, 120, 120, '파이프 500x700');

/* 토글 + 반응형 + 루프 */
function setGroupVisibility(group, on) {
  group.traverse(obj => {
    obj.visible = on;
    if (obj.isCSS2DObject && obj.element) {
      obj.element.style.display = on ? '' : 'none';
    }
  });
}
setGroupVisibility(coordGroup, false);
coordGroup.visible = false;

document.getElementById('toggleDims').onclick = () => {
  const next = !dimsGroup.visible;
  setGroupVisibility(dimsGroup, next);
  dimsGroup.visible = next;
  document.getElementById('toggleDims').textContent = `치수: ${next ? 'ON' : 'OFF'}`;
};
document.getElementById('toggleMarks').onclick = () => {
  const next = !markGroup.visible;
  setGroupVisibility(markGroup, next);
  markGroup.visible = next;
  document.getElementById('toggleMarks').textContent = `마킹영역: ${next ? 'ON' : 'OFF'}`;
};
document.getElementById('toggleCoords').onclick = () => {
  const next = !coordGroup.visible;
  setGroupVisibility(coordGroup, next);
  coordGroup.visible = next;
  document.getElementById('toggleCoords').textContent = `좌표: ${next ? 'ON' : 'OFF'}`;
};

addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight); labelRenderer.setSize(innerWidth,innerHeight);
});

/* ===== 카메라 트윈 ===== */
let camTween = null;
function easeInOut(t){ return t<.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2; }
function flyTo(center, camOpt={}){
  const target = new THREE.Vector3(center.x, center.y, center.z);
  let destPos;
  if (camOpt.pos){
    const p = camOpt.pos; destPos = new THREE.Vector3(p[0],p[1],p[2]);
  }else{
    const off = camOpt.offset ?? [600, 520, 900];
    destPos = new THREE.Vector3(center.x+off[0], center.y+off[1], center.z+off[2]);
  }
  const start = { p: camera.position.clone(), t: controls.target.clone(), t0: performance.now(), dur: camOpt.dur ?? 1200 };
  const end = { p: destPos, t: camOpt.target ? new THREE.Vector3(...camOpt.target) : target };
  camTween = { start, end };
}

/* ===== 단계 상세 툴팁 로직 ===== */
const tipEl    = document.getElementById('stepTip');
const tipTitle = document.getElementById('tipTitle');
const tipImg   = document.getElementById('tipImg');
const tipHtml  = document.getElementById('tipHtml');
const tipClose = document.getElementById('tipClose');
tipClose.onclick = ()=> hideTip();

/* 데이터 URL(간이 플레이스홀더) */
const PLACEHOLDER_IMG =
  'data:image/svg+xml;utf8,' +
  encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="800" height="450">
    <defs>
      <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
        <stop offset="0" stop-color="#1a2238"/>
        <stop offset="1" stop-color="#0f1628"/>
      </linearGradient>
    </defs>
    <rect width="100%" height="100%" fill="url(#g)"/>
    <g fill="#9ad8ff" font-family="Arial, Helvetica, sans-serif">
      <text x="50%" y="52%" text-anchor="middle" font-size="28">이미지를 설정하세요</text>
    </g>
  </svg>`);

/* 각 단계별 이미지/HTML 설명 — 필요에 맞게 수정 */
const STEP_INFO = {
  1:{ title:'① 하단 보강', img:'1.jpg', html:'잘린변을 필히 확인하시어 2번과 헷갈리지 않도록 합니다.' },
  2:{ title:'② 상단 보강', img:'2.jpg', html:'잘린벼을 필히 확인하시어 1번과 헷갈리지 않도록 합니다.' },
  3:{ title:'③ 코너 보강', img:'3.jpg', html:'보강재를 붙일 때는, 모양을 잡고 미리 가져다 대보시고 맞는지 확인한 뒤, 한쪽 벽면을 우선 부착합니다.' },
  4:{ title:'④ 코너 보강', img:'4.jpg', html:'보강재를 붙일 때는, 모양을 잡고 미리 가져다 대보시고 맞는지 확인한 뒤, 한쪽 벽면을 우선 부착합니다.' },
  5:{ title:'⑤ 1000×200 패널 보강', img:'5.jpg', html:'삼각면목 중심을 기준으로 한쪽면을 우선 부착하면 쉽게 부착됩니다. 실측을 한 치수만큼 제거 한 뒤 부착하면 코너 작업이 용이합니다.' },
  6:{ title:'⑥ 400×200 패널 보강', img:'6.jpg', html:'삼각면목 중심을 기준으로 한쪽면을 우선 부착하면 쉽게 부착됩니다' },
  7:{ title:'⑦ 400×200 패널 보강', img:'7.jpg', html:'삼각면목 중심을 기준으로 한쪽면을 우선 부착하면 쉽게 부착됩니다' },
  8:{ title:'⑧ 800×200 패널 보강', img:'8.jpg', html:'실측한 치수만큼 제거 한뒤, 부착하면 코너 작업이 용이합니다.' },
  9:{ title:'⑨ 470×150 파이프 보강', img:'9.jpg', html:'15번과 헷갈리지 않도록 주의!!' },
  10:{ title:'⑩ 300×300 파이프 보강', img:'10.jpg', html:'파이프 위에서 씌우지 말것!' },
  11:{ title:'⑪ 1000×1600 큰바닥', img:'11.jpg', html:'실측한 치수만큼 제거한 뒤, 부착하시면 코너작업이 용이합니다. 나머지 부분은 상단 부착하기전에 제거합니다.' },
  12:{ title:'⑫ 800×1000 작은바닥', img:'12.jpg', html:'접착면을 부착하지 않도록 주의!!' },
  13:{ title:'⑬ 500×450 우측 패널', img:'13.jpg', html:'14번과 헷갈리지 않도록 주의!! 튀어나온 모서리부터 부착!!' },
  14:{ title:'⑭ 600×450 좌측 패널', img:'14.jpg', html:'13번과 헷갈리지 않도록 주의!!' },
  15:{ title:'⑮ 200x500 파이프 마감', img:'15.jpg', html:'용융 및 철선 잊지 말것!' },
};
/* 현재 표시중인 툴팁의 월드좌표(따라다니기) */
const tipState = { world: null };

function showTipForStep(step){
  const info = STEP_INFO[step.id] || {};
  tipTitle.textContent = info.title || (step.label || `단계 ${step.id}`);
  tipImg.src = info.img || PLACEHOLDER_IMG;
  tipHtml.innerHTML = info.html || '이 단계의 상세 설명을 STEP_INFO에 채워 넣으세요.';
  tipEl.classList.remove('hidden');

  // 툴팁을 단계 중심에 따라다니도록 등록
  tipState.world = new THREE.Vector3(step.c[0], step.c[1]+50, step.c[2]);
  updateTipScreenPos();
}
function hideTip(){
  tipEl.classList.add('hidden');
  tipState.world = null;
}

/* 월드좌표 → 화면좌표로 변환해 툴팁 위치 갱신 */
function updateTipScreenPos(){
  if(!tipState.world) return;
  const v = tipState.world.clone();
  v.project(camera);
  let x = (v.x * 0.5 + 0.5) * window.innerWidth;
  let y = (-v.y * 0.5 + 0.5) * window.innerHeight;

  // 화면 경계 살짝 안쪽으로 클램프
  const margin = 10;
  x = Math.max(margin, Math.min(window.innerWidth - margin, x));
  y = Math.max(margin, Math.min(window.innerHeight - margin, y));

  tipEl.style.left = `${x}px`;
  tipEl.style.top  = `${y}px`;
  tipEl.style.transform = 'translate(-50%,-110%)'; // 포인트 위쪽에 띄우기
}

/* 렌더 루프 */
(function animate(){
  requestAnimationFrame(animate);
  if (camTween){
    const now=performance.now();
    const {start,end}=camTween;
    let u=(now-start.t0)/start.dur; if(u>=1){ u=1; camTween=null; }
    const k=easeInOut(u);
    camera.position.lerpVectors(start.p, end.p, k);
    controls.target.lerpVectors(start.t, end.t, k);
  }
  controls.update();

  // 툴팁 추적 위치 갱신
  if (!tipEl.classList.contains('hidden')) updateTipScreenPos();

  renderer.render(scene,camera);
  labelRenderer.render(scene,camera);
})();

/* =========================
 * 2) 아이템 제작(롤 전개 & 절단)
 * ======================= */
let isTouchDrag = false;
let makerBtn, maker, makerClose;
let rollGrid, rollSheet, cutLayer, dragHandle, lengthIndicator;

const ROLL_WIDTH_MM  = 1000;
const ROLL_LENGTH_MM = 5000;
const STEP_MM        = 100;

let mm2px = 0.2;
let curLen = 0;
let isDragging = false, dragStartY = 0, dragStartLen = 0;

document.addEventListener('DOMContentLoaded', () => {
  makerBtn       = document.getElementById('toggleMaker');
  maker          = document.getElementById('makerModal');
  makerClose     = document.getElementById('makerClose');

  rollGrid       = document.getElementById('rollGrid');
  rollSheet      = document.getElementById('rollSheet');
  cutLayer       = document.getElementById('cutLayer');
  dragHandle     = document.getElementById('dragHandle');
  lengthIndicator= document.getElementById('lengthIndicator');

  // 굵은 가이드 라인 초기세팅
  setGuideLines([800, 1150, 2750, 3550, 4150]);

  makerBtn.onclick  = () => { if (maker.classList.contains('hidden')) openMaker(); else closeMaker(); };
  makerClose.onclick= closeMaker;
  maker.addEventListener('click', (e)=>{ if(e.target===maker) closeMaker(); });

  dragHandle.addEventListener('pointerdown', onDragStart);
  dragHandle.addEventListener('pointermove', onDragMove);
  dragHandle.addEventListener('pointerup',   onDragEnd);

  window.addEventListener('resize', () => { if(!maker.classList.contains('hidden')) computeScale(); });

  // 작업순서 드롭다운/버튼 초기화
  initSequenceControls();
});

/* 모달 열기/닫기 */
function openMaker(){
  maker.classList.remove('hidden');
  computeScale();
  requestAnimationFrame(computeScale);
  updateGuideLines(curLen);
  maker.addEventListener('wheel', onWheel, { passive:false });
  maker.focus?.();
}
function closeMaker(){
  maker.classList.add('hidden');
  maker.removeEventListener('wheel', onWheel);
}

/* 스케일 계산 + 시트/절단 레이어 동기화 */
function computeScale(){
  const w = rollGrid.clientWidth * 0.9;
  mm2px = Math.max(0.05, w / ROLL_WIDTH_MM);
  rollGrid.style.setProperty('--grid', (mm2px * STEP_MM) + 'px');

  const sheetW = (ROLL_WIDTH_MM * mm2px);
  const sheetH = (curLen * mm2px);

  rollSheet.style.width  = sheetW + 'px';
  rollSheet.style.height = sheetH + 'px';
  cutLayer.style.width   = sheetW + 'px';
  cutLayer.style.height  = sheetH + 'px';

  updateLengthIndicator();
  updateSheetAppearance();
  rebuildCuts(curLen);
  updateGuideLines(curLen);
}

/* 휠 전개 */
function onWheel(e){
  e.preventDefault(); e.stopPropagation();
  const direction = e.deltaY > 0 ? 1 : -1;
  let next = curLen + (direction * STEP_MM);
  next = Math.max(0, Math.min(ROLL_LENGTH_MM, next));
  if(next !== curLen){
    curLen = next;
    rollSheet.style.height = (curLen * mm2px) + 'px';
    cutLayer.style.height  = (curLen * mm2px) + 'px';
    updateLengthIndicator();
    rebuildCuts(curLen);
    updateGuideLines(curLen);
  }
}

/* 드래그 전개 */
function onDragStart(e){
  isDragging = true;
  isTouchDrag = (e.pointerType === 'touch');
  dragHandle.setPointerCapture(e.pointerId);
  dragStartY = e.clientY;
  dragStartLen = curLen;
}
function onDragMove(e){
  if(!isDragging) return;
  const dy = dragStartY - e.clientY;       // 위로 드래그: dy>0
  const sign = isTouchDrag ? -1 : 1;       // 터치: 아래로 증가
  let next = dragStartLen + (sign * dy / mm2px);
  next = Math.round(next / STEP_MM) * STEP_MM;
  next = Math.max(0, Math.min(ROLL_LENGTH_MM, next));
  if(next !== curLen){
    curLen = next;
    rollSheet.style.height = (curLen * mm2px) + 'px';
    cutLayer.style.height  = (curLen * mm2px) + 'px';
    updateLengthIndicator();
    rebuildCuts(curLen);
    updateGuideLines(curLen);
  }
}
function onDragEnd(){ isDragging = false; }

/* 보조 UI */
function updateLengthIndicator(){
  lengthIndicator.textContent = curLen.toLocaleString() + ' mm';
}
function updateSheetAppearance(){
  if (!rollSheet) return;
  const leftBandPx = 100 * mm2px;
  rollSheet.style.backgroundImage =
    `linear-gradient(to right,
      rgba(0,0,0,0.22) 0, rgba(0,0,0,0.22) ${leftBandPx}px,
      rgba(0,0,0,0.00) ${leftBandPx}px, rgba(0,0,0,0.00) 100%)`;
  rollSheet.style.backgroundRepeat = 'no-repeat';
  rollSheet.style.backgroundSize   = '100% 100%';
}

/* ===== (가)~(마) 절단 패턴 ===== */
const GAP_PX = 6;
function px(mm){ return Math.round(mm * mm2px); }

function addPiecePx({ rightPx, bottomPx, widthPx, heightPx, label, shrink=false }){
  const el = document.createElement('div');
  el.className = 'cutPiece' + (shrink ? ' shrink' : '');
  el.style.right = (rightPx) + 'px';
  el.style.bottom= (bottomPx) + 'px';
  el.style.width = Math.max(1, widthPx - GAP_PX) + 'px';
  el.style.height= Math.max(1, heightPx - GAP_PX) + 'px';
  if(label){
    const tag = document.createElement('div');
    tag.className = 'num';
    tag.textContent = label;
    el.appendChild(tag);
  }
  cutLayer.appendChild(el);
}
function rebuildCuts(totalMm){
  if(!cutLayer) return;
  cutLayer.innerHTML = '';

  function rowRightTop(yTopMm, hMm, segments){
    const Hpx = px(hMm);
    const bottomPx = Math.max(0, px(totalMm - (yTopMm + hMm)));
    let xRight = 0;
    segments.forEach(seg=>{
      const WP = px(seg.wMm);
      addPiecePx({
        rightPx: xRight,
        bottomPx,
        widthPx: WP,
        heightPx: Hpx,
        label: seg.label,
        shrink: !!seg.shrink
      });
      xRight += WP + GAP_PX;
    });
  }

  if(totalMm >= 200){
    rowRightTop(0, 200, [
      {wMm:200, label:'① 200x200'},
      {wMm:200, label:'② 200x200'},
      {wMm:200, label:'③ 200x200'},
      {wMm:200, label:'④ 200x200'},
      {wMm:200, shrink:true},
    ]);
  }
  if(totalMm >= 400){
    rowRightTop(200, 200, [{wMm:1000, label:'⑤ 1000x200'}]);
  }
  if(totalMm >= 600){
    rowRightTop(400, 200, [
      {wMm:400, label:'⑥ 400x200'},
      {wMm:400, label:'⑦ 400x200'},
      {wMm:200, shrink:true},
    ]);
  }
  if(totalMm >= 800){
    rowRightTop(600, 200, [
      {wMm:800, label:'⑧ 800x200'},
      {wMm:200, shrink:true},
    ]);
  }
  if(totalMm >= 1150){
    const baseTop = 800, H = 350, rightW = 500;
    addPiecePx({
      rightPx: 0,
      bottomPx: Math.max(0, px(totalMm - (baseTop + 150))),
      widthPx: px(rightW),
      heightPx: px(150),
      label:'⑨ 500x150(미세조정-30)'
    });
    addPiecePx({
      rightPx: 0,
      bottomPx: Math.max(0, px(totalMm - (baseTop + 350))),
      widthPx: px(rightW),
      heightPx: px(200),
      label:'⑮ 500x200'
    });
    let xRight = px(rightW) + GAP_PX;
    const bottomPxBlock = Math.max(0, px(totalMm - (baseTop + H)));
    addPiecePx({ rightPx: xRight, bottomPx: bottomPxBlock, widthPx: px(300), heightPx: px(H), label:'⑩ 300x300' });
    xRight += px(300) + GAP_PX;
    addPiecePx({ rightPx: xRight, bottomPx: bottomPxBlock, widthPx: px(200), heightPx: px(H), shrink:true });
  }
  if(totalMm >= 2750){
    rowRightTop(1150, 1600, [{ wMm:1000, label:'⑪ 1000x1600 (미세조정 필요)' }]);
  }
  if(totalMm >= 3550){
    rowRightTop(2750, 800, [{ wMm:800, label:'⑫ 1000x800 (미세조정 필요) ' }, {wMm:200, shrink:true}]);
  }
  if(totalMm >= 4150){
    rowRightTop(3550, 600, [
      { wMm:450, label:'⑭ 450x600' },
      { wMm:450, label:'⑬ 450x500 (미세조정 -100mm)' },
      { wMm:100, shrink:true },
    ]);
  }
}

/* ===== 굵은 실선(여러 개) 유틸 ===== */
let guideLayer;
const guideEls = new Map();            // mm -> DOM 엘리먼트
let guideList = [];
function ensureGuideLayer(){
  if (!guideLayer){
    guideLayer = document.createElement('div');
    guideLayer.style.position = 'absolute';
    guideLayer.style.left = '50%';
    guideLayer.style.bottom = '0';
    guideLayer.style.transform = 'translateX(-50%)';
    guideLayer.style.pointerEvents = 'none';
    rollGrid.appendChild(guideLayer);
  }
  guideLayer.style.width = (ROLL_WIDTH_MM * mm2px) + 'px';
}
function ensureGuide(mm){
  let el = guideEls.get(mm);
  if (!el){
    el = document.createElement('div');
    el.className = 'guide-line';
    guideLayer.appendChild(el);
    guideEls.set(mm, el);
  }
  el.style.width = (ROLL_WIDTH_MM * mm2px) + 'px';
  return el;
}
function setGuideLines(mmArray){
  guideList = [...mmArray].sort((a,b)=>a-b);
  ensureGuideLayer();
  const keep = new Set(guideList);
  for (const [mm, el] of guideEls){
    if (!keep.has(mm)){ el.remove(); guideEls.delete(mm); }
  }
  guideList.forEach(mm => ensureGuide(mm));
  updateGuideLines(curLen);
}
function updateGuideLines(totalMm){
  ensureGuideLayer();
  guideList.forEach(mm => {
    const el = ensureGuide(mm);
    if (totalMm < mm){
      el.style.display = 'none';
    }else{
      el.style.display = '';
      el.style.bottom = px(totalMm - mm) + 'px';
    }
  });
}

/* =========================
 * 3) 작업순서(1~15)
 * ======================= */

/* 아이템 제작에서 쓰던 사이즈 매핑(mm) */
const SEQ_SIZES = {
  1:[200,200], 2:[200,200], 3:[200,200], 4:[200,200],
  5:[1000,200],
  6:[200,400], 7:[400,200],
  8:[200,800],
  9:[500,150],
  10:[300,350],
  11:[1000,1600],
  12:[1000,800],
  13:[450,600], 14:[450,600],
  15:[500,200],
};
/* 중심점/옵션(예시) */
const WORK_STEPS = [
  {id:1,  c:[ 400,  Y_TOP,    -798], label:'①'},
  {id:2,  c:[ 400,  Y_TOP+50, -798], label:'②', plane:'verticalZ', size:[200,200]},
  {id:3,  c:[ 402,  Y_TOP,   -1200], label:'③', plane:'verticalX', size:[200,200]},
  {id:4,  c:[   0,  Y_TOP,    -798], label:'④', plane:'verticalZ', size:[200,200]},
  {id:5,  c:[ 900,  Y_TOP,   -1200], label:'⑤'},
  {id:6,  c:[ 400,  Y_TOP,   -1000], label:'⑥', cam:{offset:[500,520,150]}},
  {id:7,  c:[ 200,  Y_TOP,    -800], label:'⑦'},
  {id:8,  c:[   0,  Y_TOP,    -450], label:'⑧', cam:{offset:[500,520,150]}},
  {id:9,  c:[ 500,  Y_TOP,    -500], label:'⑨'},
  {id:10, c:[ 500,  Y_TOP,    -500], label:'⑩'},
  {id:11, c:[ 900,  Y_TOP,    -850], label:'⑪'},
  {id:12, c:[   0,  Y_TOP,    -400], label:'⑫'},
  {id:13, c:[ 402,  Y_TOP,   -1000], label:'⑬', plane:'verticalX', size:[400,600], cam:{offset:[500,520,150]}},
  {id:14, c:[ 200,  Y_TOP+15, -798], label:'⑭', plane:'verticalZ'},
  {id:15, c:[ 500,  Y_TOP,    -500], label:'⑮'},
];

/* 시각화: 단일 스텝(지정 그룹에 그림) */
function drawSeqMark(step, targetGroup){
  const label = step.label ?? ('#'+step.id);
  const [w, h] = (step.size || SEQ_SIZES[step.id]);
  const [cx, cy, cz] = step.c;
  const color = 0x00cfe8;

  if (step.plane === 'verticalX') {
    const y1 = cy - h/2, y2 = cy + h/2;
    const z1 = cz - w/2, z2 = cz + w/2;
    addMarkRectVerticalX(cx, y1, y2, z1, z2, label, { color, opacity:0.26, outline:true, target: targetGroup });
  } else if (step.plane === 'verticalZ') {
    const y1 = cy - h/2, y2 = cy + h/2;
    const x1 = cx - w/2, x2 = cx + w/2;
    addMarkRectVerticalZ(cz, y1, y2, x1, x2, label, { color, opacity:0.26, outline:true, target: targetGroup });
  } else {
    const y = Y_TOP + 0.07;
    addMarkQuad3D([
      {x:cx - w/2, y, z:cz - h/2},
      {x:cx + w/2, y, z:cz - h/2},
      {x:cx + w/2, y, z:cz + h/2},
      {x:cx - w/2, y, z:cz + h/2},
    ], label, { color, opacity:0.24, outline:true, target: targetGroup });
  }
}

/* 자동플레이 */
const STEP_DELAY_MS = 5000;
let seqRunning = false, seqIndex = 0, seqTimer = null;

function showStepByIndex(i){
  const step = WORK_STEPS[i]; if(!step) return;
  clearGroup(seqAutoGroup);                    // 자동 표시는 항상 1개만
  drawSeqMark(step, seqAutoGroup);
  const c = new THREE.Vector3(step.c[0], step.c[1], step.c[2]);
  flyTo({x:c.x, y:c.y, z:c.z}, step.cam||{});
  showTipForStep(step);                        // ★ 단계 상세 툴팁 표시
}
function startSequence(){
  // 기존 표시(단일/자동)와 툴팁 초기화 후 시작
  clearGroup(seqSingleGroup);
  clearGroup(seqAutoGroup);
  hideTip();
  if(seqRunning) return;
  seqRunning = true; seqIndex = 0;
  document.getElementById('toggleSeq').textContent = '중지';
  stepTick();
}
function stopSequence(){
  seqRunning = false;
  clearTimeout(seqTimer); seqTimer=null;
  clearGroup(seqAutoGroup);
  document.getElementById('toggleSeq').textContent = '자동플레이';
}
function stepTick(){
  if(!seqRunning) return;
  if (seqIndex >= WORK_STEPS.length){ stopSequence(); return; }
  showStepByIndex(seqIndex++);
  seqTimer = setTimeout(stepTick, STEP_DELAY_MS);
}
document.getElementById('toggleSeq').onclick = () => {
  if(seqRunning) stopSequence();
  else startSequence();
};

/* 단일 단계 이동(표시는 항상 1개만 유지) */
function goToStep(id){
  // 자동 진행 중이면 중지
  if (seqRunning) stopSequence();
  // 기존 단일 표시 제거 후, 해당 단계만 표시
  clearGroup(seqSingleGroup);
  const step = WORK_STEPS.find(s=>s.id===id); if(!step) return;
  drawSeqMark(step, seqSingleGroup);
  const c = new THREE.Vector3(step.c[0], step.c[1], step.c[2]);
  flyTo({x:c.x, y:c.y, z:c.z}, step.cam||{});
  showTipForStep(step);                        // ★ 단일 단계에서도 툴팁 표시
}

/* 드롭다운 초기화 */
function initSequenceControls(){
  const stepSel = document.getElementById('seqStep');
  const btnGo   = document.getElementById('btnGoStep');
  if(!stepSel || !btnGo) return;
  stepSel.innerHTML = '';
  for(let i=1;i<=15;i++){
    const o=document.createElement('option'); o.value=i; o.textContent=i; stepSel.appendChild(o);
  }
  stepSel.value='1';
  btnGo.onclick = () => {
    const id = parseInt(stepSel.value,10);
    if(Number.isFinite(id)) goToStep(id);
  };
}
</script>

<!-- 아이템 제작 모달 -->
<div id="makerModal" class="modal hidden" tabindex="-1">
  <div class="window">
    <div class="m-header">
      <div class="m-title">아이템 제작</div>
      <button class="m-close" id="makerClose">닫기 ✕</button>
    </div>

    <div class="m-body">
      <div class="rollArea">
        <div class="rollGrid" id="rollGrid">
          <div class="rollSheet" id="rollSheet"></div>
          <div class="cutLayer"  id="cutLayer"></div>
          <div class="dragHandle" id="dragHandle">↕ 드래그 / 휠로 펼치기 (100mm 단위)</div>
          <div class="lengthIndicator" id="lengthIndicator">0 mm</div>
        </div>
      </div>
    </div>
  </div>
</div>
</body>
</html>
