<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<title>ë°©ìˆ˜íŒ(1500Ã—1200, ë…¸ì¹˜ 400Ã—400) Â· r147 UMD Â· ì£¼ì„ë²„ì „</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html,body{height:100%;margin:0;background:#0b1220;color:#e9eef6;
            font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #stage{position:fixed;inset:0}
  #ui{
    position:fixed;left:12px;top:12px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;
    background:rgba(10,16,28,.86);border:1px solid rgba(255,255,255,.12);border-radius:12px;
    padding:8px 10px;backdrop-filter:blur(8px);z-index:10
  }
  #ui button{
    font-size:16px;padding:8px 14px;border-radius:10px;border:1px solid rgba(255,255,255,.3);
    background:rgba(40,40,60,.85);color:#fff;cursor:pointer
  }
  #ui button:hover{ background:rgba(80,80,120,.95) }
  .label{padding:2px 6px;border-radius:6px;background:rgba(0,0,0,.65);
         border:1px solid rgba(255,255,255,.18);color:#fff;font-size:12px;white-space:nowrap}
  .label-dim{padding:2px 6px;border-radius:6px;background:rgba(0,0,0,.65);
             border:1px solid rgba(255,0,0,.6);color:#ff4444;font-size:12px;white-space:nowrap}
/* ===== ì•„ì´í…œ ì œì‘ ëª¨ë‹¬ ===== */
.modal.hidden { display: none }
.modal {
  position: fixed; inset: 0; z-index: 9999;
  background: rgba(0,0,0,.45); backdrop-filter: blur(4px);
  display:flex; align-items:center; justify-content:center;
}
.modal .window{
  width:95vw; height:95vh; border-radius:16px;
  background:#0f1424; color:#e9eef6; border:1px solid rgba(255,255,255,.12);
  display:flex; flex-direction:column; overflow:hidden;
  box-shadow: 0 20px 60px rgba(0,0,0,.5);
}
.m-header{
  display:flex; align-items:center; justify-content:space-between; gap:8px;
  padding:10px 14px; border-bottom:1px solid rgba(255,255,255,.12);
  background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,0));
}
.m-title{ font-weight:600 }
.m-close{
  background:transparent; color:#fff; border:1px solid rgba(255,255,255,.25);
  padding:6px 10px; border-radius:10px; cursor:pointer;
}
.m-close:hover{ background:rgba(255,255,255,.08) }

/* ìƒë‹¨: ì•„ì´í…œ ì„ ë°˜ (4ì¹¸ ê¸°ë³¸, ì¢Œìš° ìŠ¬ë¼ì´ë“œë¡œ ìµœëŒ€ 15) */
.shelfWrap{ position:relative; padding:10px 40px; border-bottom:1px solid rgba(255,255,255,.08) }
.shelfNav{
  position:absolute; top:50%; transform:translateY(-50%);
  width:32px; height:32px; border-radius:50%;
  display:grid; place-items:center; border:1px solid rgba(255,255,255,.25);
  background:rgba(255,255,255,.06); cursor:pointer; user-select:none;
}
.shelfNav:hover{ background:rgba(255,255,255,.12) }
.shelfNav.left{ left:8px } .shelfNav.right{ right:8px }
.shelf{
  display:grid; grid-auto-flow:column; grid-auto-columns:minmax(140px, 1fr);
  gap:10px; overflow-x:auto; scroll-behavior:smooth; padding-bottom:6px;
}
.slot{
  height:90px; border-radius:12px; border:1px dashed rgba(255,255,255,.25);
  display:flex; align-items:center; justify-content:center; position:relative;
  background:rgba(255,255,255,.03); min-width:140px;
}
.slot.empty::after{
  content:"Empty"; font-size:12px; color:#9fb0d0; opacity:.6;
}
.thumb{
  --bg:#2a3350;
  width:110px; height:72px; border-radius:10px; background:var(--bg);
  display:flex; align-items:center; justify-content:center; position:relative;
  box-shadow:inset 0 0 0 1px rgba(255,255,255,.15);
}
.thumb .piece{
  background:#ffcc00; opacity:.85; box-shadow:inset 0 0 0 1px rgba(0,0,0,.25);
}
.thumb .dims{
  position:absolute; right:6px; bottom:4px; font-size:11px; color:#111; background:#ffcc00;
  padding:2px 4px; border-radius:6px; font-weight:600;
}

/* ë³¸ë¬¸: ë¡¤(ì‹œíŠ¸ì§€) ì˜ì—­ */
.m-body{ flex:1; display:flex; align-items:stretch; position:relative }
.rollArea{ flex:1; display:flex; align-items:flex-end; justify-content:center; overflow:hidden; position:relative }
.rollGrid{
  position:relative; width:100%; height:100%; overflow:hidden;
  display:flex; align-items:flex-end; justify-content:center;
  /* 100mm ê²©ì (JSì—ì„œ --grid í¬ê¸° ì£¼ì…) */
  background:
    repeating-linear-gradient(0deg, rgba(255,255,255,.08) 0, rgba(255,255,255,.08) 1px, transparent 1px, transparent var(--grid, 100px)),
    repeating-linear-gradient(90deg, rgba(255,255,255,.08) 0, rgba(255,255,255,.08) 1px, transparent 1px, transparent var(--grid, 100px));
}
.rollSheet{
  position:absolute; bottom:0; /* ê°€ìš´ë° ì •ë ¬ */
  width:600px; height:0px;      /* JSì—ì„œ mmâ†’pxë¡œ ìˆ˜ì • */
  background:rgb(92, 91, 96,0.8);
  outline:1px solid rgba(255,0,0,.7);
}
.dragHandle{
  position:absolute; bottom:0; left:50%; transform:translateX(-50%);
  width:280px; text-align:center; padding:8px 10px; margin-bottom:6px;
  background:rgba(0,0,0,.55); border:1px solid rgba(255,255,255,.25); border-radius:12px;
  cursor:ns-resize; user-select:none; font-size:13px;
}
.lengthIndicator{
  position:absolute; right:10px; bottom:10px;
  background:rgba(0,0,0,.65); border:1px solid rgba(255,255,255,.25);
  padding:8px 10px; border-radius:10px; font-weight:600; min-width:120px; text-align:right;
}

/* ìë¥´ê¸° í™•ì¸ */
.cutConfirm{
  position:absolute; right:18px; top:62px; display:flex; gap:8px; align-items:center;
  background:rgba(0,0,0,.6); border:1px solid rgba(255,255,255,.25); padding:8px 10px; border-radius:10px;
}
.cutConfirm.hidden{ display:none }
.cutConfirm .msg{ font-weight:600 }
.cutConfirm .btns button{
  margin-left:6px; border-radius:8px; border:1px solid rgba(255,255,255,.25);
  background:rgba(255,255,255,.08); color:#fff; padding:6px 10px; cursor:pointer;
}
.cutConfirm .btns button:hover{ background:rgba(255,255,255,.16) }

/* ì„ íƒëœ ì•„ì´í…œ ì •ë³´ */
.itemInfo{
  position:absolute; left:14px; bottom:14px;
  background:rgba(0,0,0,.6); border:1px solid rgba(255,255,255,.25);
  padding:8px 10px; border-radius:10px; font-size:13px;
}		
/* ëª¨ë‹¬ ë‚´ë¶€ì—ì„œ ë°”ë””ë¡œ ìŠ¤í¬ë¡¤ ì „íŒŒ ë°©ì§€ */
#makerModal, #makerModal * {
  overscroll-behavior: contain;
}
	 
</style>
</head>
<body>
<div id="stage"></div>

<!-- UI: ì¹˜ìˆ˜/ë§ˆí‚¹ í† ê¸€ -->
<div id="ui">
  <button id="toggleDims">ì¹˜ìˆ˜: ON</button>
  <button id="toggleMarks">ë§ˆí‚¹ì˜ì—­: ON</button>
  <button id="toggleCoords">ì¢Œí‘œ: ON</button>  <!-- âœ… ì¶”ê°€ -->
  <button id="toggleMaker">ì•„ì´í…œ ì œì‘</button>
</div>

<!-- r147 UMD (ë¡œì»¬) -->
<script src="./lib/three.min.js"></script>
<script src="./lib/controls/OrbitControls.js"></script>
<script src="./lib/renderers/CSS2DRenderer.js"></script>

<script>
/* ============================================================
 * 0) ê³µí†µ ì„¤ì •(ë‹¨ìœ„: mm)  â€” ìˆ«ìë§Œ ë°”ê¿”ë„ ì „ì²´ ì¬êµ¬ì„±
 * ========================================================== */
const W = 1500, D = 1200;      // ë°”ë‹¥íŒ ì „ì²´ í¬ê¸° (X, Z)
const T = 0.1;                 // ë°”ë‹¥íŒ ë‘ê»˜(Y)
const NOTCH_X = 400, NOTCH_Z = 400, NOTCH_ORIGIN_Z = 800; // ë…¸ì¹˜(íŒŒë¨¹ìŒ)
const Y_TOP = T;               // ë°”ë‹¥ ìƒë©´ ë†’ì´ (= 0.1)
const WALL_H = 300, WALL_T = 70;           // ë²½ ë†’ì´Â·í­
const TRI_W = 40, TRI_H = 40;              // ì‚¼ê° ë©´ëª©(ë‹¨ë©´)
const PILLAR_H = 300;                       // (ì˜ˆì œ) ê¸°ë‘¥ ë†’ì´
const fmt0 = n => Number(n).toFixed(0);

/* ============================================================
 * 1) ì”¬/ì¹´ë©”ë¼/ë Œë”ëŸ¬/ì»¨íŠ¸ë¡¤
 * ========================================================== */
const scene   = new THREE.Scene();
const camera  = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 10000);
const renderer= new THREE.WebGLRenderer({ antialias:true, alpha:false, powerPreference:'high-performance' });
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.5));  // í”„ë ˆì„ ì•ˆì •í™”
document.getElementById('stage').appendChild(renderer.domElement);

// 2D ë¼ë²¨ ë Œë”ëŸ¬(CSS)
const labelRenderer = new THREE.CSS2DRenderer();
labelRenderer.setSize(innerWidth,innerHeight);
labelRenderer.domElement.style.position="fixed";
labelRenderer.domElement.style.inset="0";
labelRenderer.domElement.style.pointerEvents="none";
document.body.appendChild(labelRenderer.domElement);

// ì»¨íŠ¸ë¡¤(ë§ˆìš°ìŠ¤: ì´ë™/ì¤Œ/íšŒì „)
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.dampingFactor = 0.08;
controls.enablePan = true; controls.screenSpacePanning = true; controls.panSpeed = 1.2;
controls.zoomSpeed = 1.0; controls.rotateSpeed = 0.8;
controls.mouseButtons = { LEFT:THREE.MOUSE.PAN, MIDDLE:THREE.MOUSE.DOLLY, RIGHT:THREE.MOUSE.ROTATE };
controls.touches      = { ONE:THREE.TOUCH.PAN, TWO:THREE.TOUCH.DOLLY_ROTATE };

// ì¡°ëª…Â·ê·¸ë¦¬ë“œ
scene.add(new THREE.HemisphereLight(0xffffff,0x223344,0.85));
scene.add(new THREE.AxesHelper(200));
const grid = new THREE.GridHelper(4000, 40, 0x3355ff, 0x223355);
grid.material.opacity = 0.25; grid.material.transparent = true;
scene.add(grid);

// í™ˆ í¬ì§€ì…˜
camera.position.set(1600,800,1600);
controls.target.set(W/2,0,D/2);

/* ============================================================
 * 2) ë°”ë‹¥íŒ(í•©íŒ) + ë…¸ì¹˜
 *    - 2D Shape(XZ) â†’ Extrude(depth=T) â†’ XYâ†’XZë¡œ ëˆ•í˜
 * ========================================================== */
const plateShape = new THREE.Shape();
plateShape.moveTo(0,0); plateShape.lineTo(W,0); plateShape.lineTo(W,D);
plateShape.lineTo(0,D); plateShape.lineTo(0,0);

// ë…¸ì¹˜ (0,800)~(400,1200) : ì•„ë˜ ì‚¬ê°ì„ "hole"ë¡œ ëš«ìŒ
const hole = new THREE.Path();
hole.moveTo(0,NOTCH_ORIGIN_Z);
hole.lineTo(NOTCH_X,NOTCH_ORIGIN_Z);
hole.lineTo(NOTCH_X,NOTCH_ORIGIN_Z+NOTCH_Z);
hole.lineTo(0,NOTCH_ORIGIN_Z+NOTCH_Z);
hole.lineTo(0,NOTCH_ORIGIN_Z);
plateShape.holes.push(hole);

const plateGeo  = new THREE.ExtrudeGeometry(plateShape,{ depth:T, bevelEnabled:false, steps:1 });
const plateMesh = new THREE.Mesh(plateGeo, new THREE.MeshPhongMaterial({ color:0xf0d8b0 }));
plateMesh.rotation.x = -Math.PI/2;         // XYâ†’XZ
scene.add(plateMesh);

/* ============================================================
 * 3) ì£¼ìš” ê¼­ì§€ì (ì›”ë“œì¢Œí‘œ) â€” ë¼ë²¨/ì¹˜ìˆ˜/ë²½/ë©´ëª©ì˜ ê¸°ì¤€
 * ========================================================== */
const V = {
  A:new THREE.Vector3(0,       Y_TOP,   0),
  B:new THREE.Vector3(W,       Y_TOP,   0),
  C:new THREE.Vector3(W,       Y_TOP,  -D),
  D:new THREE.Vector3(0,       Y_TOP,  -D),
  E:new THREE.Vector3(0,       Y_TOP,  -NOTCH_ORIGIN_Z),
  F:new THREE.Vector3(NOTCH_X, Y_TOP,  -NOTCH_ORIGIN_Z),
  G:new THREE.Vector3(NOTCH_X, Y_TOP,  -(NOTCH_ORIGIN_Z+NOTCH_Z))
};

// ë‹¤ê°í˜• ì„¼íŠ¸ë¡œì´ë“œ(ì¹˜ìˆ˜ì„  ë°©í–¥/ë²½ ì˜¤í”„ì…‹ íŒì •ì— ì‚¬ìš©)
function polygonCentroid(pts){
  let A=0,cx=0,cz=0;
  for(let i=0;i<pts.length;i++){
    const p=pts[i], q=pts[(i+1)%pts.length];
    const cross=p.x*q.z - q.x*p.z;
    A+=cross; cx+=(p.x+q.x)*cross; cz+=(p.z+q.z)*cross;
  }
  A*=0.5; return new THREE.Vector3(cx/(6*A), Y_TOP, cz/(6*A));
}
const CENTROID = polygonCentroid([V.A,V.B,V.C,V.D,V.E,V.F,V.G]);

/* ============================================================
 * 4) ìœ í‹¸ë¦¬í‹° (ë¼ë²¨/ì¹˜ìˆ˜/í‹±/ê³µìš© ì¬ì§ˆ)
 * ========================================================== */
const matWall   = new THREE.MeshPhongMaterial({ color: 0xe5c99b });
const matTri    = new THREE.MeshPhongMaterial({ color: 0xcaa77a });
const matPillar = new THREE.MeshPhongMaterial({ color: 0xd7b98a });

function makeLabel(pos,text,cls='label'){
  const el=document.createElement('div'); el.className=cls; el.textContent=text;
  const lab=new THREE.CSS2DObject(el); lab.position.copy(pos); return lab;
}

// ì¹˜ìˆ˜ ê·¸ë£¹(í† ê¸€ ëŒ€ìƒ)
const dimsGroup = new THREE.Group(); scene.add(dimsGroup);
const coordGroup = new THREE.Group(); scene.add(coordGroup); // â† ì´ ì¤„ì´ ìœ„ì— ìˆì–´ì•¼ í•¨
// ê³µìš©: ì„ ë¶„ + ë¼ë²¨
function addDimSegment(a,b,text){
  const g = new THREE.BufferGeometry().setFromPoints([a,b]);
  const m = new THREE.LineDashedMaterial({ color:0xffffff, dashSize:40, gapSize:20, transparent:true, opacity:.95 });
  const line = new THREE.Line(g,m); line.computeLineDistances(); dimsGroup.add(line);
  if(text){ const mid=a.clone().add(b).multiplyScalar(0.5); dimsGroup.add(makeLabel(mid,text,'label-dim')); }
}
// ê³µìš©: í‹±(í‘œì‹)
function addTickAt(p,dir,len=20){
  const a=p.clone().add(dir.clone().multiplyScalar(-len*0.5));
  const b=p.clone().add(dir.clone().multiplyScalar( len*0.5));
  const g=new THREE.BufferGeometry().setFromPoints([a,b]);
  dimsGroup.add(new THREE.Line(g,new THREE.LineBasicMaterial({color:0xffffff,transparent:true,opacity:.95})));
}

/* ============================================================
 * 5) ë²½(ê¸¸ì´ L, í­ t=70, ë†’ì´ H=300)  â€” place='center'|'inset'|'outset'
 * ========================================================== */
function addVerticalBoard(p1, p2, name1, name2, H = WALL_H, t = WALL_T, place = 'outset') {
  const dir = p2.clone().sub(p1); dir.y = 0;
  const L   = Math.max(0.0001, Math.hypot(dir.x, dir.z));
  const angY = Math.atan2(dir.z, dir.x);

  const box  = new THREE.BoxGeometry(L, H, t);
  const wall = new THREE.Mesh(box, matWall);

  const mid = p1.clone().add(p2).multiplyScalar(0.5);
  wall.position.set(mid.x, Y_TOP + H / 2, mid.z);
  wall.rotation.y = angY;

  // ë‚´Â·ì™¸ì¸¡ ì˜¤í”„ì…‹(ìš”êµ¬: ì™¸ì¸¡ìœ¼ë¡œ 70 -> place='outset')
  if (place !== 'center') {
    const n = new THREE.Vector3(-dir.z, 0, dir.x).normalize();
    const toCent = CENTROID.clone().sub(mid).setY(0);
    const nIsIn = n.dot(toCent) > 0;
    const outwardN = nIsIn ? n.clone().multiplyScalar(-1) : n.clone();
    const inwardN  = outwardN.clone().multiplyScalar(-1);
    const offsetN  = (place === 'inset') ? inwardN : outwardN;
    wall.position.add(offsetN.multiplyScalar(t * 0.5));
  }

  scene.add(wall);

  // â”€â”€ ìƒë‹¨ ì¢Œí‘œ ë¼ë²¨(í† ê¸€ ì—°ë™ì„ ìœ„í•´ coordGroupì— ì¶”ê°€)
  const t1 = p1.clone(); t1.y = Y_TOP + H;
  const t2 = p2.clone(); t2.y = Y_TOP + H;

  coordGroup.add(
    makeLabel(
      t1.clone().add(new THREE.Vector3(0, 20, 0)),
      `${name1}@ (${fmt0(t1.x)},${fmt0(t1.y)},${fmt0(t1.z)})`
    )
  );
  coordGroup.add(
    makeLabel(
      t2.clone().add(new THREE.Vector3(0, 20, 0)),
      `${name2}@ (${fmt0(t2.x)},${fmt0(t2.y)},${fmt0(t2.z)})`
    )
  );

  return wall;
}


/* ============================================================
 * 6) ì‚¼ê° ë©´ëª©(ë‹¨ë©´ 40Ã—40) â€” ë³€ ë°©í–¥ìœ¼ë¡œ ì••ì¶œ(+Z), +Xë¥¼ ë‚´ì¸¡ìœ¼ë¡œ ì •ë ¬
 * ========================================================== */
function createTriShape(w=TRI_W,h=TRI_H){
  const s=new THREE.Shape(); s.moveTo(0,0); s.lineTo(w,0); s.lineTo(0,h); s.lineTo(0,0); return s;
}
function addTriPrismOnEdge(p1,p2,label='edge',w=TRI_W,h=TRI_H){
  const zAxis = p2.clone().sub(p1); zAxis.y=0; const L=Math.max(0.0001,zAxis.length()); zAxis.normalize();
  const yAxis = new THREE.Vector3(0,1,0);
  let   xAxis = yAxis.clone().cross(zAxis).normalize();
  const mid   = p1.clone().add(p2).multiplyScalar(0.5);
  const toC   = CENTROID.clone().sub(mid).setY(0);
  if(xAxis.dot(toC)<0) xAxis.negate(); // +X=ë‚´ì¸¡

  const tri = createTriShape(w,h);
  const geo = new THREE.ExtrudeGeometry(tri,{ depth:L, bevelEnabled:false, steps:1 });
  const mesh= new THREE.Mesh(geo,matTri);
  mesh.setRotationFromMatrix(new THREE.Matrix4().makeBasis(xAxis,yAxis,zAxis));
  mesh.position.copy(p1);
  scene.add(mesh);
  return mesh;
}

/* ============================================================
 * 7) ê¸°ë‘¥(70Ã—70Ã—300) â€” ë°‘ë©´ ì‚¬ê° 4ì ìœ¼ë¡œ ìƒì„±(ì¶•ì •ë ¬)
 * ========================================================== */
function addAxisAlignedPillar(corners, h = PILLAR_H, label = '') {
  const xs = corners.map(p => p.x), zs = corners.map(p => p.z);
  const minX = Math.min(...xs), maxX = Math.max(...xs);
  const minZ = Math.min(...zs), maxZ = Math.max(...zs);
  const Wp = Math.abs(maxX - minX), Dp = Math.abs(maxZ - minZ);
  const cx = (minX + maxX) / 2, cz = (minZ + maxZ) / 2;

  const mesh = new THREE.Mesh(new THREE.BoxGeometry(Wp, h, Dp), matPillar);
  mesh.position.set(cx, Y_TOP + h / 2, cz);
  scene.add(mesh);

  // ìƒë‹¨ 4ì  ë¼ë²¨(ì¢Œí‘œ í† ê¸€ ì—°ë™: coordGroupì— ì¶”ê°€)
  const ty = Y_TOP + h;
  [[minX, minZ], [maxX, minZ], [maxX, maxZ], [minX, maxZ]].forEach((p, i) => {
    const v = new THREE.Vector3(p[0], ty, p[1]);
    coordGroup.add(  // â† scene ëŒ€ì‹  coordGroup
      makeLabel(
        v.clone().add(new THREE.Vector3(0, 20, 0)),
        `${label ? label + ' ' : ''}T${i + 1} (${fmt0(v.x)},${fmt0(v.y)},${fmt0(v.z)})`
      )
    );
  });

  return mesh;
}

/* ============================================================
 * 8) ì¹˜ìˆ˜ ë³´ì¡°ì„  â€” ì™¸ê³½/ë…¸ì¹˜/ì„¸ë¡œ/ë‘ê»˜
 * ========================================================== */
function addDimToward(p1,p2,text,offset=-60){
  const d=p2.clone().sub(p1).setY(0).normalize();
  const n=new THREE.Vector3(-d.z,0,d.x);
  const mid=p1.clone().add(p2).multiplyScalar(0.5);
  const sgn = (n.dot(CENTROID.clone().sub(mid).setY(0))>=0)? 1 : -1;
  const off=n.multiplyScalar(sgn*offset);
  const a=p1.clone().add(off); a.y=Y_TOP+1;
  const b=p2.clone().add(off); b.y=Y_TOP+1;
  addDimSegment(a,b,text);
}
function addHeightDimAt(point,height=300,text='300',offset=100){
  // ë°”ê¹¥ìª½ìœ¼ë¡œ ì¹˜ìˆ˜ì„  ë‚´ë³´ë‚´ê¸°
  const outward = point.clone().setY(0).sub(CENTROID.clone().setY(0));
  if(outward.lengthSq()===0) outward.set(1,0,0);
  outward.normalize().multiplyScalar(offset);
  const base=new THREE.Vector3(point.x+outward.x,Y_TOP,point.z+outward.z);
  const top =new THREE.Vector3(point.x+outward.x,Y_TOP+height,point.z+outward.z);
  addDimSegment(base,top,text);
  const tickDir=new THREE.Vector3(-outward.z,0,outward.x).normalize();
  addTickAt(base,tickDir); addTickAt(top,tickDir);
}
/*
function addThicknessDimOnEdge(p1,p2,thickness=70,text='70',y=Y_TOP+40){
  const mid=p1.clone().add(p2).multiplyScalar(0.5);
  const dir=p2.clone().sub(p1).setY(0).normalize();
  let n=new THREE.Vector3(-dir.z,0,dir.x);
  if(n.dot(mid.clone().sub(CENTROID.clone().setY(mid.y)))<0) n.negate(); // ë°”ê¹¥ìª½
  const a=mid.clone().add(n.clone().multiplyScalar(-thickness/2)); a.y=y;
  const b=mid.clone().add(n.clone().multiplyScalar( thickness/2)); b.y=y;
  addDimSegment(a,b,text); addTickAt(a,dir); addTickAt(b,dir);
}
/*
/* ============================================================
 * 9) ë§ˆí‚¹ì˜ì—­ (ë²„íŠ¼ í† ê¸€) â€” ì–‡ì€ ë°˜íˆ¬ëª… íŒ¨ì¹˜ + ì™¸ê³½ì„  + ë¼ë²¨
 *    - addMarkRect(cx,cz,w,d,label) : ì¤‘ì‹¬/í­/ê¹Šì´
 *    - addMarkRectByCorners([p1,p2,p3,p4],label) : ê¼­ì§€ì  4ê°œ(ì¶•ì •ë ¬)
 * ========================================================== */
const markGroup = new THREE.Group(); scene.add(markGroup);

function addMarkRect(cx,cz,w,d,label='MARK'){
  const mesh = new THREE.Mesh(
    new THREE.PlaneGeometry(w,d),
    new THREE.MeshBasicMaterial({ color:0xff0000, transparent:true, opacity:0.22, depthWrite:false })
  );
  mesh.rotation.x = -Math.PI/2;
  mesh.position.set(cx, Y_TOP+0.05, cz);
  markGroup.add(mesh);

  // ì™¸ê³½ì„ 
  const hw=w/2, hd=d/2;
  const poly=[[-hw,0,-hd],[hw,0,-hd],[hw,0,hd],[-hw,0,hd]].map(([x,_,z])=>new THREE.Vector3(cx+x, Y_TOP+0.06, cz+z));
  const g=new THREE.BufferGeometry().setFromPoints([...poly, poly[0]]);
  const line=new THREE.Line(g,new THREE.LineBasicMaterial({ color:0xff0000, transparent:true, opacity:0.9 }));
  markGroup.add(line);

  // ë¼ë²¨
  markGroup.add(makeLabel(new THREE.Vector3(cx, Y_TOP+0.06, cz), label, 'label-dim'));
}
function addMarkRectByCorners(corners,label='MARK'){
  const xs=corners.map(p=>p.x), zs=corners.map(p=>p.z);
  const cx=(Math.min(...xs)+Math.max(...xs))/2;
  const cz=(Math.min(...zs)+Math.max(...zs))/2;
  addMarkRect(cx, cz, Math.abs(Math.max(...xs)-Math.min(...xs)), Math.abs(Math.max(...zs)-Math.min(...zs)), label);
}

/* ===== 9.x) 3D ë§ˆí‚¹ ìœ í‹¸: ì•„ë¬´ í‰ë©´(ì„¸ë¡œ/ê¸°ìš¸ê¸° í¬í•¨)ì—ì„œ ë™ì‘ ===== */
// corners: [{x,y,z}, ... 4ê°œ] (ì‹œê³„/ë°˜ì‹œê³„ ì•„ë¬´ê±°ë‚˜ OK; ê·œì¹™ë§Œ ìœ ì§€)
function addMarkQuad3D(corners, label='MARK', { color=0xff0000, opacity=0.22, outline=true } = {}){
  if (corners.length !== 4) { console.warn('addMarkQuad3D: 4ê°œ ê¼­ì§€ì  í•„ìš”'); return; }
  const p = corners.map(c => new THREE.Vector3(c.x, (c.y ?? Y_TOP+0.05), c.z));

  // ë‘ ì‚¼ê°í˜•(0-1-2, 0-2-3)ë¡œ ì‚¬ê° ìƒì„±
  const pos = new Float32Array([
    p[0].x,p[0].y,p[0].z,  p[1].x,p[1].y,p[1].z,  p[2].x,p[2].y,p[2].z,
    p[0].x,p[0].y,p[0].z,  p[2].x,p[2].y,p[2].z,  p[3].x,p[3].y,p[3].z,
  ]);
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  geo.computeVertexNormals();

  const mat = new THREE.MeshBasicMaterial({
    color, transparent:true, opacity, side:THREE.DoubleSide, depthWrite:false
  });
  const mesh = new THREE.Mesh(geo, mat);
  markGroup.add(mesh);

  // ì™¸ê³½ì„ 
  if (outline) {
    const loopGeo = new THREE.BufferGeometry().setFromPoints([p[0],p[1],p[2],p[3],p[0]]);
    const loopMat = new THREE.LineBasicMaterial({ color, transparent:true, opacity:0.9 });
    markGroup.add(new THREE.Line(loopGeo, loopMat));
  }

  // ë¼ë²¨: ë©´ì˜ ì¤‘ì‹¬ + ë²•ì„  ë°©í–¥ìœ¼ë¡œ ì‚´ì§ ë„ì›€
  const centroid = p[0].clone().add(p[1]).add(p[2]).add(p[3]).multiplyScalar(0.25);
  const normal = new THREE.Triangle(p[0],p[1],p[2]).getNormal(new THREE.Vector3()).normalize();
  const labelPos = centroid.clone().add(normal.multiplyScalar(5));
  markGroup.add(makeLabel(labelPos, label, 'label-dim'));

  return mesh;
}

// í¸ì˜: YZ í‰ë©´(ì„¸ë¡œ, x ê³ ì •)
function addMarkRectVerticalX(x, y1, y2, z1, z2, label='MARK', opts){
  return addMarkQuad3D([
    {x:x, y:y1, z:z1},
    {x:x, y:y1, z:z2},
    {x:x, y:y2, z:z2},
    {x:x, y:y2, z:z1},
  ], label, opts);
}

// í¸ì˜: XY í‰ë©´(ì„¸ë¡œ, z ê³ ì •)
function addMarkRectVerticalZ(z, y1, y2, x1, x2, label='MARK', opts){
  return addMarkQuad3D([
    {x:x1, y:y1, z:z},
    {x:x2, y:y1, z:z},
    {x:x2, y:y2, z:z},
    {x:x1, y:y2, z:z},
  ], label, opts);
}


// AE ê°™ì€ ë²½ ë‘ê»˜ë¥¼ "ë²½ ë°”ê¹¥ìª½(gapë§Œí¼)"ìœ¼ë¡œ ì¹˜ìˆ˜ì„  í‘œì‹œ
function addThicknessDimOnEdgeOutside(p1, p2, thickness=70, text='70', y=Y_TOP+40, gap=35){
  const mid = p1.clone().add(p2).multiplyScalar(0.5);
  const dir = p2.clone().sub(p1); dir.y = 0; dir.normalize();        // ë³€ ë°©í–¥(í‰í–‰ì„ /í‹± ë°©í–¥)
  let   n   = new THREE.Vector3(-dir.z, 0, dir.x);                    // ë³€ ìˆ˜ì§(ë‘ê»˜ ë°©í–¥)
  const toOut = mid.clone().sub(CENTROID.clone().setY(mid.y));        // ë°”ê¹¥ íŒì •
  if (n.dot(toOut) < 0) n.negate();                                   // +n = ë°”ê¹¥

  // ë‘ â€˜ë©´â€™ì˜ ì¤‘ì‹¬ì (ë‚´ì¸¡/ì™¸ì¸¡)  âœ ì—¬ê¸°ì„œ gapë§Œí¼ ë°”ê¹¥ìœ¼ë¡œ ë‚´ë³´ë‚´ ì¹˜ìˆ˜ì„  ìœ„ì¹˜ ê²°ì •
  const innerFace = mid.clone().add(n.clone().multiplyScalar(-thickness/2)); innerFace.y = y; // AEë©´
  const outerFace = mid.clone().add(n.clone().multiplyScalar( thickness/2)); outerFace.y = y; // ë°”ê¹¥ë©´
  const a = innerFace.clone().add(n.clone().multiplyScalar(gap));  // ì¹˜ìˆ˜ì„  ìª½ ë‚´ì¸¡ íˆ¬ì˜ì 
  const b = outerFace.clone().add(n.clone().multiplyScalar(gap));  // ì¹˜ìˆ˜ì„  ìª½ ì™¸ì¸¡ íˆ¬ì˜ì 

  // ë©´ â†’ ì¹˜ìˆ˜ì„ ê¹Œì§€ ì—°ì¥ì„ (Extension lines)
  const extMat = new THREE.LineBasicMaterial({ color:0xffffff, transparent:true, opacity:.85 });
  //dimsGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([innerFace, a]), extMat));
  dimsGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([outerFace, b]), extMat));

  // ë°”ê¹¥ìª½ì— ìœ„ì¹˜í•œ ë‘ ì  aâ€“b ì‚¬ì´ì— ë‘ê»˜ ì¹˜ìˆ˜ì„ (ê¸¸ì´ = thickness)
  addDimSegment(a, b, text);

  // ëí‘œì‹(í‹±)ì€ ë³€ ë°©í–¥ìœ¼ë¡œ
  addTickAt(a, dir);
  addTickAt(b, dir);
}

// ìƒˆ í˜¸ì¶œ: AE ë©´ ê¸°ì¤€ ë°”ê¹¥ìª½(gap=40mm)ìœ¼ë¡œ ë‘ê»˜ ì¹˜ìˆ˜
addThicknessDimOnEdgeOutside(V.A, V.E, 70, '70', Y_TOP+340,35);

/* ============================================================
 * 10) ì‹¤ì œ ìƒì„± íŒŒì´í”„ë¼ì¸
 * ========================================================== */
// (1) ë²½ 4ê°œ(ì™¸ì¸¡ìœ¼ë¡œ í­ 70)
addVerticalBoard(V.A,V.E,'A','E',WALL_H,WALL_T,'outset');
addVerticalBoard(V.E,V.F,'E','F',WALL_H,WALL_T,'outset');
addVerticalBoard(V.F,V.G,'F','G',WALL_H,WALL_T,'outset');
addVerticalBoard(V.G,V.C,'G','C',WALL_H,WALL_T,'outset');

// (2) ì‚¼ê° ë©´ëª© 4ê°œ (AE, EF, FG, GC) â€” í˜¸ì¶œ ë°©í–¥ì„ ì´ë¯¸ ì¡°ì •
addTriPrismOnEdge(V.E,V.A,'AE');
addTriPrismOnEdge(V.F,V.E,'EF');
addTriPrismOnEdge(V.G,V.F,'FG');
addTriPrismOnEdge(V.C,V.G,'GC');

// (3) ì½”ë„ˆ ìê¸°(ì˜ˆ: F ì½”ë„ˆ) â€” ì‚¬ìš©ì ì§€ì • 5ì (ìµœê·¼ì— ì“°ì‹  ê°’ ê¸°ì¤€)
(function addCornerWedgeF(){
  const mat = matTri;
  const VTX = [
    new THREE.Vector3(400, Y_TOP+0,  -800),
    new THREE.Vector3(400, Y_TOP+40, -800),
    new THREE.Vector3(400, Y_TOP+0,  -760),
    new THREE.Vector3(440, Y_TOP+0,  -800),
    new THREE.Vector3(440, Y_TOP+0,  -760)
  ];
  const idx = [ 0,3,4, 0,4,2,  1,3,0, 1,0,2, 1,2,4, 1,4,3 ];
  const pos = new Float32Array(VTX.flatMap(v=>[v.x,v.y,v.z]));
  const geo = new THREE.BufferGeometry(); geo.setAttribute('position', new THREE.BufferAttribute(pos,3)); geo.setIndex(idx); geo.computeVertexNormals();
  scene.add(new THREE.Mesh(geo,mat));
})();

// (4) ê¸°ë‘¥ 2ê°œ(ì˜ˆì œ: E, G)
addAxisAlignedPillar([{x:0,y:0,z:-800},{x:-70,y:0,z:-800},{x:-70,y:0,z:-870},{x:0,y:0,z:-870}], 300, '');
addAxisAlignedPillar([{x:400,y:0,z:-1200},{x:330,y:0,z:-1200},{x:330,y:0,z:-1270},{x:400,y:0,z:-1270}], 300, '');

// (5) ì¹˜ìˆ˜ë³´ì¡°ì„  â€” ì™¸ê³½/ë…¸ì¹˜/ì„¸ë¡œ/ë‘ê»˜
addDimToward(V.A,V.B,'1500');     // X ì™¸ê³½
addDimToward(V.B,V.C,'1200');     // Z ì™¸ê³½
addDimToward(V.E,V.F,'400');      // ë…¸ì¹˜ X
addDimToward(V.F,V.G,'400');      // ë…¸ì¹˜ Z
addHeightDimAt(V.A, 300, '300');  // A ë†’ì´
//addThicknessDimOnEdge(V.A,V.E,70,'70', Y_TOP+340); // AE ë‘ê»˜


//ê³µìš©í† ê¸€ ìœ í‹¸ ì¶”ê°€ ( ë¼ë²¨ë„ ê°™ì´ êº¼ì§€ê²Œ )
function setGroupVisibility(group, on) {
  group.traverse(obj => {
    obj.visible = on;                         // three.js ê°€ì‹œì„±
    if (obj.isCSS2DObject && obj.element) {   // CSS2D ë¼ë²¨ DOMë„ ë™ê¸°í™”
      obj.element.style.display = on ? '' : 'none';
    }
  });
}
// ğŸ”½ ì´ˆê¸° ìƒíƒœ: ì¢Œí‘œ OFF (ë¼ë²¨ DOMê¹Œì§€ í•¨ê»˜ ë¹„í™œì„±)
setGroupVisibility(coordGroup, false);
coordGroup.visible = false;
document.getElementById('toggleCoords').textContent = 'ì¢Œí‘œ: OFF';


/* ============================================================
 * 6-2 ë§ˆí‚¹ ìˆœì°¨
 * ========================================================== */
// (6) ë§ˆí‚¹ì˜ì—­(ì˜ˆì‹œ 2ê°œ) â€” ë²„íŠ¼ìœ¼ë¡œ í† ê¸€
addMarkRectVerticalX(0, Y_TOP, Y_TOP+300, 0, -50, 'ë§ˆí‚¹ì˜ì—­-50mm');
addMarkRect(750, -25, 1500, 50, 'ë§ˆí‚¹ì˜ì—­-50mm');                    // ì¤‘ì‹¬í˜•  ì¤‘ì‹¬ì¢Œí‘œ + ë„“ì´ + zë„“ì´
addMarkQuad3D([  {x:0, y:Y_TOP+40, z: 0},  {x:0, y:Y_TOP+40, z:-50},  {x:40, y:0, z:-50},  {x:40, y:0, z: 0},], 'ë§ˆí‚¹ì˜ì—­-50mm');
addMarkRect(1450, -600, 100, 1200, 'ë§ˆí‚¹ì˜ì—­-100mm');                    // ì¤‘ì‹¬í˜•  ì¤‘ì‹¬ì¢Œí‘œ + ë„“ì´ + zë„“ì´
// AE ë²½ ë°”ê¹¥ë©´(ëŒ€ëµ x = -35 ë¶€ê·¼)ì— ì„¸ë¡œ ë§ˆí‚¹: ë†’ì´ 0.1~300, z: -900~-700
addMarkQuad3D([  {x:1500, y:Y_TOP+40, z: -1200},  {x:1500, y:0, z:-1160},  {x:1400, y:0, z:-1160},  {x:1400,  y:Y_TOP+40,  z: -1200},], 'ë§ˆí‚¹ì˜ì—­-100mm');
addMarkRectVerticalZ(-1200, Y_TOP,Y_TOP+300,  1400,  1500, 'ë§ˆí‚¹ì˜ì—­-100mm'); // zì‹œì‘ì  ,y=0~300,x=1400~1500 
addMarkQuad3D([  {x:1500, y:Y_TOP+300, z: -1200},  {x:350, y:Y_TOP+300, z:-1200},  {x:350, y:Y_TOP+300, z:-1250},  {x:1500,  y:Y_TOP+300,  z: -1250},], 'ë§ˆí‚¹ì˜ì—­-50mm');
addMarkQuad3D([  {x:350, y:Y_TOP+300, z: -1200},  {x:400, y:Y_TOP+300, z:-1200},  {x:400, y:Y_TOP+300, z:-800},  {x:350,  y:Y_TOP+300,  z: -800},], 'ë§ˆí‚¹ì˜ì—­-50mm');
addMarkQuad3D([  {x:350, y:Y_TOP+300, z: -800},  {x:350, y:Y_TOP+300, z:-850}, {x:-50,  y:Y_TOP+300,  z: -850}, {x:-50, y:Y_TOP+300, z:-800},], 'ë§ˆí‚¹ì˜ì—­-50mm');
addMarkQuad3D([  {x:-50, y:Y_TOP+300, z: -800},  {x:-50, y:Y_TOP+300, z:-0}, {x:0,  y:Y_TOP+300,  z: 0}, {x:0, y:Y_TOP+300, z:-800},], 'ë§ˆí‚¹ì˜ì—­-50mm');
addMarkRect(500, -500, 120, 120, 'íŒŒì´í”„ 500x700');                    // ì¤‘ì‹¬í˜•  ì¤‘ì‹¬ì¢Œí‘œ + ë„“ì´ + zë„“ì´
//addMarkRectByCorners([{x:1500,y:0,z:-1000},{x:1500,y:300,z:-1000},{x:1400,y:300,z:-1000},{x:1400,y:0,z:-1000}], 'ë§ˆí‚¹ì˜ì—­-100mm');
//addMarkRectByCorners([{x:420,y:0,z:-500},{x:700,y:0,z:-500},{x:700,y:0,z:-800},{x:420,y:0,z:-800}], 'ì‘ì—…ì˜ì—­-2');
//addMarkRectByCorners([{x:0,y:0,z:-700},{x:100,y:0,z:-700},{x:100,y:0,z:-800},{x:420,y:0,z:-800}], 'ì‘ì—…ì˜ì—­-2');

// GC ë²½ ë°”ê¹¥ë©´(ëŒ€ëµ z = -1200-35)ì— ì„¸ë¡œ ë§ˆí‚¹: x: 1100~1400, ë†’ì´ 0.1~300
//addMarkRectVerticalZ(-1200,-35, Y_TOP, Y_TOP+300, 1100, 1400, 'GC-ì„¸ë¡œë§ˆí‚¹');

// ê¼­ì§€ì  4ê°œë¡œ ì„ì˜ í‰ë©´(ê¸°ìš¸ì–´ì§„ ë©´ë„ ê°€ëŠ¥)
//addMarkQuad3D([  {x:330, y:Y_TOP+10,  z:-900},  {x:400, y:Y_TOP+10,  z:-900},  {x:400, y:Y_TOP+180, z:-900},  {x:330, y:Y_TOP+180, z:-900},], 'G-ì„¸ë¡œíŒ¨ì¹˜');
/* ============================================================
 * 11) í† ê¸€ & ë£¨í”„
 * ========================================================== */
document.getElementById('toggleDims').onclick = () => {
   const next = !dimsGroup.visible;
  setGroupVisibility(dimsGroup, next);   // âœ… ë¼ë²¨ê¹Œì§€ í™•ì‹¤íˆ í† ê¸€
  dimsGroup.visible = next;              // ì¼ê´€ì„± ìœ ì§€
  document.getElementById('toggleDims').textContent = `ì¹˜ìˆ˜: ${next ? 'ON' : 'OFF'}`;
};
document.getElementById('toggleMarks').onclick = () => {
  const next = !markGroup.visible;
  setGroupVisibility(markGroup, next);          // âœ… ë¼ë²¨ê¹Œì§€ í™•ì‹¤íˆ ON/OFF
  // group.visibleë„ ë§ì¶°ë‘ (ì¼ê´€ì„±)
  markGroup.visible = next;
  document.getElementById('toggleMarks').textContent = `ë§ˆí‚¹ì˜ì—­: ${next ? 'ON' : 'OFF'}`;
};
// ì¢Œí‘œ í† ê¸€
document.getElementById('toggleCoords').onclick = () => {
  const next = !coordGroup.visible;
  setGroupVisibility(coordGroup, next);   // âœ… ë¼ë²¨ DOMê¹Œì§€ ë™ê¸°í™”
  coordGroup.visible = next;              // ì¼ê´€ì„± ìœ ì§€
  document.getElementById('toggleCoords').textContent = `ì¢Œí‘œ: ${next ? 'ON' : 'OFF'}`;
};

addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight); labelRenderer.setSize(innerWidth,innerHeight);
});
(function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene,camera);
  labelRenderer.render(scene,camera);
})();

/* ì•„ì´í…œ ì œì‘*/
let isTouchDrag = false;     // ë“œë˜ê·¸ê°€ í„°ì¹˜ì¸ì§€ ì—¬ë¶€
let wheelTimer = null;       // íœ (ìŠ¤í¬ë¡¤) ë©ˆì¶¤ ê°ì§€ìš© íƒ€ì´ë¨¸

// ===== ì•„ì´í…œ ì œì‘ ëª¨ë‹¬ ë¡œì§ =====
let makerBtn, maker, makerClose;
let shelf, shelfPrev, shelfNext;
let rollGrid, rollSheet, dragHandle, lengthIndicator, cutConfirm, cutLenSpan, cutYes, cutNo, itemInfo;

const ROLL_WIDTH_MM  = 1000;   // 1m
const ROLL_LENGTH_MM = 5000;   // 5m
const STEP_MM        = 100;    // 100mm ìŠ¤í…
const MAX_SLOTS      = 15;

let mm2px = 0.2;
let curLen = 0, pendingLen = 0;
let isDragging = false, dragStartY = 0, dragStartLen = 0;

// ğŸ”½ í˜ì´ì§€ì˜ ëª¨ë“  DOMì´ ì¤€ë¹„ëœ ë’¤ì— ë°”ì¸ë”©/ì´ˆê¸°í™”
document.addEventListener('DOMContentLoaded', () => {
  // 1) ìš”ì†Œ ë°”ì¸ë”©
  makerBtn       = document.getElementById('toggleMaker');
  maker          = document.getElementById('makerModal');
  makerClose     = document.getElementById('makerClose');

  shelf          = document.getElementById('shelf');
  shelfPrev      = document.getElementById('shelfPrev');
  shelfNext      = document.getElementById('shelfNext');

  rollGrid       = document.getElementById('rollGrid');
  rollSheet      = document.getElementById('rollSheet');
  dragHandle     = document.getElementById('dragHandle');
  lengthIndicator= document.getElementById('lengthIndicator');
  cutConfirm     = document.getElementById('cutConfirm');
  cutLenSpan     = document.getElementById('cutLen');
  cutYes         = document.getElementById('cutYes');
  cutNo          = document.getElementById('cutNo');
  itemInfo       = document.getElementById('itemInfo');
  

  // 2) ìŠ¬ë¡¯ ì´ˆê¸°í™” (ì—¬ê¸°ì„œ í•˜ë©´ #shelfê°€ nullì¼ ì¼ì´ ì—†ìŒ)
  initShelf();

  // 3) ë„¤ë¹„ê²Œì´ì…˜/ì˜¤í”ˆ ë°”ì¸ë”©
  shelfPrev.onclick = ()=> shelf.scrollBy({ left: -shelf.clientWidth, behavior:'smooth' });
  shelfNext.onclick = ()=> shelf.scrollBy({ left:  shelf.clientWidth, behavior:'smooth' });

  //makerBtn.onclick  = openMaker;
  //makerClose.onclick= closeMaker;


// === ë²„íŠ¼ ë°”ì¸ë”© ===
makerBtn.onclick = () => {
  if (maker.classList.contains('hidden')) openMaker();
  else closeMaker();
};
makerClose.onclick = closeMaker;

// ì˜¤ë²„ë ˆì´ ë¹ˆ ê³³ í´ë¦­ ì‹œ ë‹«ê¸° (ëª¨ë‹¬ ë°”ê¹¥ í´ë¦­)
maker.addEventListener('click', (e) => {
  if (e.target === maker) closeMaker();
});
// (ì„ íƒ) ì˜¤ë²„ë ˆì´ ë¹ˆ ê³³ í´ë¦­ ì‹œ ë‹«ê¸°
maker?.addEventListener('click', (e) => {
  if (e.target === maker) closeMaker();
});

// (ê¶Œì¥) ëª¨ë‹¬ ë‚´ë¶€ ìŠ¤í¬ë¡¤ ì „íŒŒ ì°¨ë‹¨
maker?.addEventListener('wheel', (e) => { e.preventDefault(); e.stopPropagation(); }, { passive:false });


  // 4) ë“œë˜ê·¸ í•¸ë“¤
  dragHandle.addEventListener('pointerdown', onDragStart);
  dragHandle.addEventListener('pointermove', onDragMove);
  dragHandle.addEventListener('pointerup',   onDragEnd);

  // 5) ë¦¬ì‚¬ì´ì¦ˆ
  window.addEventListener('resize', () => {
    if(!maker.classList.contains('hidden')) computeScale();
  });
});

// ===== ì´í•˜ ë³´ì¡° í•¨ìˆ˜ë“¤ì€ ê·¸ëŒ€ë¡œ ì‚¬ìš© =====
function initShelf(){
  shelf.innerHTML = '';
  for(let i=0;i<MAX_SLOTS;i++){
    const s = document.createElement('div');
    s.className = 'slot empty';
    s.dataset.index = i;
    shelf.appendChild(s);
  }
}

// ëª¨ë‹¬ ì—´ê¸° (í•œ ë²ˆë§Œ ì„ ì–¸!)
function openMaker(){
  if (!maker) return;
  maker.classList.remove('hidden');

  // ë ˆì´ì•„ì›ƒ í™•ì • í›„ ìŠ¤ì¼€ì¼/í‘œì‹œ ë³´ì •
  computeScale();
  requestAnimationFrame(computeScale);

  // ëª¨ë‹¬ ì „ì²´ì—ì„œ íœ  ì²˜ë¦¬ (ìì‹ ì–´ë””ì„œ êµ´ë ¤ë„ ë™ì‘)
  maker.addEventListener('wheel', onWheel, { passive:false });
  maker.focus?.();
}

// âœ… ëª¨ë‹¬ ë‹«ê¸° (ìƒˆë¡œ ì¶”ê°€)
function closeMaker(){
  if (!maker) return;
  maker.classList.add('hidden');

  // ì»· í™•ì¸/ì„ íƒ ì •ë³´ ìˆ¨ê¹€
  hideCutConfirm();
  itemInfo && (itemInfo.style.display = 'none');

  // íœ  ë¦¬ìŠ¤ë„ˆ í•´ì œ(ì¤‘ë³µ ë°©ì§€)
  maker.removeEventListener('wheel', onWheel);
}

// (ì„ íƒ) ì „ì—­ ë…¸ì¶œì´ í•„ìš”í•˜ë©´ ì£¼ì„ í•´ì œ
// window.openMaker  = openMaker;
// window.closeMaker = closeMaker;


function computeScale(){
  const w = rollGrid.clientWidth * 0.9;
  mm2px = Math.max(0.05, w / ROLL_WIDTH_MM);
  rollGrid.style.setProperty('--grid', (mm2px * STEP_MM) + 'px');
  rollSheet.style.width  = (ROLL_WIDTH_MM * mm2px) + 'px';
  rollSheet.style.height = (curLen * mm2px) + 'px';
  updateLengthIndicator();
  updateSheetAppearance(); // â˜… ì¶”ê°€
}
//ë§ˆìš°ìŠ¤ íœ  í•¸ë“¤ëŸ¬ ì¶”ê°€
function onWheel(e){
  // ëª¨ë‹¬ ì•ˆì—ì„œ ìŠ¤í¬ë¡¤ì´ í˜ì´ì§€ë¡œ ì „íŒŒë˜ì§€ ì•Šë„ë¡
  e.preventDefault();
 e.stopPropagation();
  // deltaY > 0 (ì•„ë˜ë¡œ ìŠ¤í¬ë¡¤) â‡’ ì‹œíŠ¸ì§€ê°€ "ì˜¬ë¼ì˜¤ê²Œ" ê¸¸ì´ ì¦ê°€
 const direction = e.deltaY > 0 ? 1 : -1; // ì•„ë˜ë¡œ êµ´ë¦¬ë©´ +, ìœ„ë¡œ êµ´ë¦¬ë©´ -
  let next = curLen + (direction * STEP_MM); // STEP_MM=100
  next = Math.max(0, Math.min(ROLL_LENGTH_MM, next));

  if(next !== curLen){
    curLen = next;
    rollSheet.style.height = (curLen * mm2px) + 'px';
    updateLengthIndicator();

    // ë©ˆì¶˜ ë’¤ 0.5ì´ˆ í›„ ì»· í™•ì¸
    clearTimeout(wheelTimer);
    wheelTimer = setTimeout(() => {
      if(curLen > 0){
        pendingLen = curLen;
        showCutConfirm(pendingLen);
      }
    }, 500);
  }
}

// ë“œë˜ê·¸ í•¸ë“¤ëŸ¬ë“¤
function onDragStart(e){
   isDragging = true;
  isTouchDrag = (e.pointerType === 'touch');   // â˜… í„°ì¹˜ ì—¬ë¶€ ê¸°ë¡
  dragHandle.setPointerCapture(e.pointerId);
  dragStartY = e.clientY;
  dragStartLen = curLen;
  hideCutConfirm();
}

function onDragMove(e){
  if(!isDragging) return;
  const dy = dragStartY - e.clientY;           // ìœ„ë¡œ ë“œë˜ê·¸: dy>0
  const sign = isTouchDrag ? -1 : 1;           // â˜… í„°ì¹˜ëŠ” ë°˜ëŒ€ë¡œ(ì•„ë˜ë¡œ=ì¦ê°€)
  let next = dragStartLen + (sign * dy / mm2px);
  next = Math.max(0, Math.min(ROLL_LENGTH_MM, Math.round(next / STEP_MM) * STEP_MM));
  if(next !== curLen){
    curLen = next;
    rollSheet.style.height = (curLen * mm2px) + 'px';
    updateLengthIndicator();
  }
}
function onDragEnd(){
  if(!isDragging) return;
  isDragging = false;
  if(curLen > 0){
    pendingLen = curLen;
    showCutConfirm(pendingLen);
  }
}

function updateLengthIndicator(){
  lengthIndicator.textContent = curLen.toLocaleString() + ' mm';
}
function showCutConfirm(len){
  cutLenSpan.textContent = len.toLocaleString();
  cutConfirm.classList.remove('hidden');
}
function hideCutConfirm(){ cutConfirm.classList.add('hidden'); }

cutNo && (cutNo.onclick = hideCutConfirm);
if (cutYes) {
  cutYes.onclick = () => {
    if(!pendingLen) return;
    addItemToShelf({ widthMm: ROLL_WIDTH_MM, lengthMm: pendingLen });
    curLen = 0;
    rollSheet.style.height = '0px';
    updateLengthIndicator();
    hideCutConfirm();
  };
}

function updateSheetAppearance(){
  if (!rollSheet) return;
  const leftBandPx = 100 * mm2px; // 100mm â†’ px
  // ì‹œíŠ¸ê°€ ê°€ì§„ ê¸°ì¡´ ë°°ê²½ìƒ‰/ì´ë¯¸ì§€ëŠ” ìœ ì§€í•˜ê³ , ì–´ë‘ìš´ ì˜¤ë²„ë ˆì´ë§Œ ì–¹ìŒ
  rollSheet.style.backgroundImage =
    `linear-gradient(to right,
      rgba(0,0,0,0.22) 0, rgba(0,0,0,0.22) ${leftBandPx}px,
      rgba(0,0,0,0.00) ${leftBandPx}px, rgba(0,0,0,0.00) 100%)`;
  rollSheet.style.backgroundRepeat = 'no-repeat';
  rollSheet.style.backgroundSize   = '100% 100%'; // ìš”ì†Œ í¬ê¸°ì— ë§ì¶¤
  // (ì„ íƒ) ê¸°ë³¸ ë°°ê²½ìƒ‰ì´ ì—†ë‹¤ë©´ ê°€ë³ê²Œ ì„¸íŒ…
  if (!rollSheet.style.backgroundColor) {
    rollSheet.style.backgroundColor = 'rgba(255,255,255,0.9)';
  }
}


function addItemToShelf({ widthMm, lengthMm }){
  const empty = Array.from(shelf.children).find(s => s.classList.contains('empty'));
  if(!empty){ alert('ìŠ¬ë¡¯ì´ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤. (ìµœëŒ€ 15)'); return; }
  empty.classList.remove('empty');

  const th = document.createElement('div'); th.className = 'thumb';
  const pad = 6, TW = 110 - pad*2, TH = 72 - pad*2;
  const scale = Math.min(TW / widthMm, TH / lengthMm);
  const pw = Math.max(4, Math.round(widthMm * scale));
  const ph = Math.max(4, Math.round(lengthMm * scale));

  const piece = document.createElement('div');
  piece.className = 'piece';
  piece.style.width = pw+'px'; piece.style.height = ph+'px';
  th.appendChild(piece);

  const dims = document.createElement('div'); dims.className = 'dims';
  dims.textContent = `1000Ã—${lengthMm}`;
  th.appendChild(dims);

  empty.appendChild(th);

  empty.onclick = () => {
    itemInfo.style.display = '';
    itemInfo.textContent = `ì„ íƒëœ ì•„ì´í…œ: 1000mm Ã— ${lengthMm}mm`;
  };
}
</script>
<!-- ì•„ì´í…œ ì œì‘ ëª¨ë‹¬ -->
<div id="makerModal" class="modal hidden" tabindex="-1">
  <div class="window">
    <div class="m-header">
      <div class="m-title">ì•„ì´í…œ ì œì‘</div>
      <button class="m-close" id="makerClose">ë‹«ê¸° âœ•</button>
    </div>

    <div class="shelfWrap">
      <div class="shelfNav left"  id="shelfPrev">â€¹</div>
      <div class="shelfNav right" id="shelfNext">â€º</div>
      <div class="shelf" id="shelf">
        <!-- ìµœëŒ€ 15ì¹¸, ì´ˆê¸°ëŠ” Empty -->
      </div>
    </div>

    <div class="m-body">
      <div class="rollArea">
        <div class="rollGrid" id="rollGrid">
          <div class="rollSheet" id="rollSheet"></div>
          <div class="dragHandle" id="dragHandle">â†• ì•„ë˜ì—ì„œ ìœ„ë¡œ ë“œë˜ê·¸í•˜ì—¬ í¼ì¹˜ê¸° (100mm ë‹¨ìœ„)</div>
          <div class="lengthIndicator" id="lengthIndicator">0 mm</div>
          <div class="cutConfirm hidden" id="cutConfirm">
            <div class="msg">ìë¥´ê² ìŠµë‹ˆê¹Œ? (<span id="cutLen">0</span> mm)</div>
            <div class="btns">
              <button id="cutYes">ë„¤</button>
              <button id="cutNo">ì•„ë‹ˆì˜¤</button>
            </div>
          </div>
          <div class="itemInfo" id="itemInfo" style="display:none;"></div>
        </div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
